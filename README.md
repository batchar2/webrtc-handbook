# WebRTC handbook.

## [Введение.](https://tools.ietf.org/html/draft-ietf-rtcweb-overview-15)

WebRTC - это набор спецификаций, описывающих трансляцию аудио\видео и сообщений (data streams) в режиме реального времени. Каждый раз обращаться к WebRTC как к набору спецификаций не слишком удобно, поэтому дальше в тексте я буду писать WebRTC, спецфикация, или просто протокол, в зависимости от контекста.

Основные действующие лица:

* WebRTC браузер, он же WebRTC User Agent (WebRTC UA) - это приложение, которое умеет WebRTC на уровне протокола и реализует правильное Javascript API
* WebTRC не браузер, известный так же как WebRTC приложение (WebRTC device\WebRTC native application) - это приложение, которое умеет WebRTC на уровне протокола и не предоставляет никакого Javascript API
* WebRTC конечная точка (WebRTC endpoint) - это приложение, которое умеет WebRTC на уровне протокола
* WebRTC-совместимая конечная точка (WebRTC-compatible endpoint) - это приложение, которое умеет WebRTC на уровне протокола, но не полностью, т.е. реализует только часть спецификации
* WebRTC шлюз - это приложение, которое транслирует WebRTC трафик WebRTC несовместимым клиентам

Базовая схема взаимодействия:

```

                +-----------+             +-----------+
                |   Web     |             |   Web     |
                |           |  Signaling  |           |
                |           |-------------|           |
                |  Server   |   path      |  Server   |
                |           |             |           |
                +-----------+             +-----------+
                     /                           \
                    /                             \ Application-defined
                   /                               \ over
                  /                                 \ HTTP/Websockets
                 /  Application-defined over         \
                /   HTTP/Websockets                   \
               /                                       \
         +-----------+                           +-----------+
         |JS/HTML/CSS|                           |JS/HTML/CSS|
         +-----------+                           +-----------+
         +-----------+                           +-----------+
         |           |                           |           |
         |           |                           |           |
         |  Browser  | ------------------------- |  Browser  |
         |           |          Media path       |           |
         |           |                           |           |
         +-----------+                           +-----------+

                      
```
Рис 1: Browser RTC Trapezoid (не берусь это переводить). [Источник](https://tools.ietf.org/html/draft-ietf-rtcweb-overview-15)

На данной схеме изображено взаимодействие двух браузеров, но их можно заменить любым WebRTC-совместимой конечной точкой.

Протокол опиcывает два уровня взаимодействия:

* сигнальный (signaling path)
* медиа (media path)

Спецификация не накладывает никаких ограничений на реализацию транспорта сигнального уровня, дается только детальное описание сигнальных датаграмм (SDP) и их последовательность, но каким образом они будут доставлены от клиента клиенту остается на откуп разработчикам. Медиа уровень служит для передачи данных\аудио\видео преимущественно по udp. Задачей сигнального уровня является наладка и открытие медиа канала(-ов), а так же управление ими. Допустим вполне нормальный кейс, когда открывается медиа канал (только data streams), после переписки один из клиентов звонит другому, а тот в свою очередь шарит ему свой экран. Так вот для реализации подобного сценария совершенно не нужно создавать новую сессию, а воспользоваться уже существующей, добавив новые медиа потоки. Подобные изменения осуществляются как раз на сигнальном уровне, когда информация о новых медиа-потоках синхронизируется между конечными точками и применяется.

Спецификация состоит из двух частей:

* описание протокола (IETF спецификации)
* описание Javascript API (W3C спецификации)

Здесь будет рассмотрена только IETF часть спецификации.

В целом предназначение WebRTC упростить и унифицировать разработку приложений, работающих с потоковыми данными, особенно при клиент-серверном взаимодействии, а это онлайн-кинотеатры, мессенджеры с возможностью видео звонков, приложения для организации конференц-связи, IP-телефония и т.д. Протокол имеет peet-to-peer природу, где каждая из сторон имеет равные права и нет разницы, что за приложение на другой стороне соединения: другой браузер, медиа сервер, медиа гейтвей или мобильный клиент. Это означает, что при звонке от одного клиента к другому им нужен только сигнальный сервер для обмена SDP датаграммами.

Модель взаимодействия в реальном времени для браузерных приложений не подразумевает, что браузер будет обладать всей функциональностью, достаточной для того, чтобы выступать в роли телефона и юнита конференц-связи; цель в том чтобы предоставить web-приложению функционал, достаточный, чтобы работая совместно с бэкендом, реализовать функционал телефонии, конференц-связи и т.д.

Однако, даже та функциональность, которой наделен WebRTC совместимый браузер, позволяет двум браузерам обмениваться потоковыми данными напрямую, с минимальной поддержкой со стороны бекенда (только сигнальный уровень).

```

                        +------------------------+  On-the-wire
                        |                        |  Protocols
                        |      Servers           |--------->
                        |                        |
                        |                        |
                        +------------------------+
                                    ^
                                    |
                                    |
                                    | HTTP/
                                    | Websockets
                                    |
                                    |
                      +----------------------------+
                      |    Javascript/HTML/CSS     |
                      +----------------------------+
                   Other  ^                 ^RTC
                   APIs   |                 |APIs
                      +---|-----------------|------+
                      |   |                 |      |
                      |                 +---------+|
                      |                 | Browser ||  On-the-wire
                      | Browser         | RTC     ||  Protocols
                      |                 | Function|----------->
                      |                 |         ||
                      |                 |         ||
                      |                 +---------+|
                      +---------------------|------+
                                            |
                                            V
                                       Native OS Services


```
Рис 2: WebRTC совместимый браузер.

Браузер является WebRTC совместимым если поддерживает:

* Транспорт данных (data transport) - TCP, UDP и средства для безопасной установки соединений между участниками обмена, а так же функциональность, позволяющую решить когда отправлять данные: контроль переполнения\загруженности, оценка пропускной способности и т.д.
* Кадрирование данных (data framing) - RTP и другие форматы, использующиеся в качестве контейнеров, а так же поддержку их функций по обеспечению конфиденциальности и целостности.
* Фоматы данных - описанный спецификацией набор audio\video кодеков, а так же форматов для передачи данных и шаринга документов. Плюс механизм, позволяющий описать поддерживаемые форматы другому клиенту, при установлении сессии.
* Управление соединением - установка соединения, соглашение по форматам данных, изменение форматов данных для установленного соединения.
* Представление и управление (presentation and control) - механизмы обеспечивающие предсказуемость и наглядность работы с потоковыми данными для клиента, т.е. браузер должен предоставить возможность web-приложению таким образом организовать работу с потоковыми данными, чтобы это было прозрачно для пользователя, чтобы он в любой момент времени понимал, куда\откуда и какие потоковые данные передаются, а так же предоставить возможность контролировать этот процесс, т.е. пользователь может отреагировать на соединение (принять\отклонить) при этом он должен иметь всю необходимую информацию для этого (кто звонит, например), а так же сам инициировать соединение. Так же пользователь должен иметь возможность самому решить какие потоковые данные передавать, а какие нет.
* Функции поддержки локальных систем (local system support functions) - механизмы локальной аутентификации и авторизации, доступ к системным вызовам ОС, эхо-подавление и возможность локальной записи медиаданных.

Первые три пункта описывают инфраструктуру медиа-транспорта. Остальные три пункта описывают медиа-сервис. Как минимум первые пять пунктов браузер должен поддерживать, чтобы быть WebRTC совместимым. 

## Транспорт данных.

Под транспортом данных понимается отправка\получение данных через сетевые интерфейсы на обоих концах соединения, а так же взаимодействие с промежуточными сервисами, ретранслирующими данные без внесения изменений, например TURN серверы. А так же включает функционал по контролю перегрузки/блокирования канала, для прекращения передачи данных. WebTRC клиенты должны поддерживать работу с транспортными протоколами описанными [здесь](https://tools.ietf.org/html/draft-ietf-rtcweb-transports-15).

## Кадрирование данных и безопасность.

Транспортом для медиа-данных является [RTP](https://tools.ietf.org/html/rfc3550) протокол. Однако, поддержка защищенного аналога [SRTP](https://tools.ietf.org/html/rfc3711) ОБЯЗАТЕЛЬНА для всех WebRTC клиентов.

Более подробно работа с RTP\SRTP в рамках WebRTC описана [здесь](https://tools.ietf.org/html/draft-ietf-rtcweb-rtp-usage-26). Требования по безопасности WebRTC соединений описаны [здесь](https://tools.ietf.org/html/draft-ietf-rtcweb-security-08), описание механизмов, реализующих эти требования, приведены [здесь](https://tools.ietf.org/html/draft-ietf-rtcweb-security-arch-12). Каждый WebRTC клиент (endpoint) должен поддерживать спецификации по безопасности.

## Форматы данных.

Данная спецификация предоставляет возможность клиентам договориться о форматах для каждого из медиа-потоков (видео\аудио), согласовав форматы из списка поддерживаемых на каждом из клиентов. При этом, чтобы такая договоренность в целом была достижима, определены минимальные требования по поддержке [аудио-кодеков](https://tools.ietf.org/html/rfc7874) и [видео-кодеков](https://tools.ietf.org/html/rfc7742). При этом разработчики могут добавить поддержку любых дополнительных форматов и кодеков помимо минимума, описанного в спецификации.

## Управление соединением.

Методы, механизмы и требования по установке, поддержке и завершению соединений это обширная область, которая спроектирована таким образом, чтобы обеспечить, как совместимость, так и свободу для инноваций.

Основные принципы:

* Процесс согласования WebRTC соединений должен реализовывать ту же модель SDP запросов\ответов как в [SIP](https://tools.ietf.org/html/rfc3264), в связи с этим SIP сервер легко использовать в качестве сигнального сервера для WebRTC.
* Должна быть возможна поддержка старых (legacy) SIP устройств, которые поддерживают ICE, RTP и SDP механизмы, кодеки и механизмы безопасности без использования медиа-гейтвея. Возможно дополнительно понадобиться наличие сигнального сервиса, для согласования сингальных схем между WEB и SIP клиентами.
* Когда новый кодек определен и SDP для него описан рабочей группой MMUSIC (MMUSIC WG) - никакой дополнительной стандартизации не нужно для использования его в браузерах. Т.е. добавление новых кодеков со своими специфичными SDP параметрами никак не меняет API между браузером и web-приложением. Как только браузер начинает поддерживать новый кодек, старые приложение, написанные до этого момента, должны автоматически получить возможность использовать этот кодек, когда потребуется без изменений в JS коде.

Подробнее о браузероном API и управлении соединениями написано [здесь](https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-15). Все WebRTC браузеры должны реализовывать эту спецификацию. Другие WebRTC-приложения должны так же реализовывать механизмы описанные в данной спецификации (Bundle, RTCP-mux, Trickle ICE), кроме Javascript API.

## Представление и управление.

Самой важной частью управления является пользовательское управление взаимодействием браузера с IO устройствами и каналами коммуникации. Очень важно, чтобы пользователь понимал куда и кому его аудио\видео\текст транслируются и по какой причине. Данные механизмы описаны в [peer connection API](https://www.w3.org/TR/webrtc) и в [media capture API](https://www.w3.org/TR/mediacapture-streams). Реализация этих спецификаций обязательна для WebRTC браузеров.

## Функции поддержки локальных систем.

Это функции напрямую влияющие на пользовательское взаимодействие с приложением, алгоритмы реализации которых не нуждаются в координации между клиентами. К локальным функциям относятся эхо-подавление, управление громкостью, управление камерой (настройка фокуса, например), различные видео-фильтры и т.д.

Отдельные части системы могут иметь сходные свойства, например:

* Эхо-подавление
* Настройки приватности, например, если разрешен удаленный доступ к камере, то приложение должно уведомить клиента кто использует его камеру и предоставить возможность отменить данное разрешение
* Автоматическая нормализация аудио-потоков

Требования для WebRTC систем по работе с аудио описаны [здесь](https://tools.ietf.org/html/rfc7874). Рекомендуемое API контроля локальных устройств - [здесь](https://www.w3.org/TR/mediacapture-streams/).

## Соображения о безопасности.

Безопасность web-приложений работающих с потоковыми данными в реальном времени можно разделить на несколько частей:

* Безопасность компонент - браузеры, мобильные клиенты и все вовлеченные в процесс сервисы.
* Безопасность коммуникационных каналов.
* Безопасность идентификации - когда каждый из участников является тем за кого себя выдает.

Данная тема раскрывается в следующих спецификациях:

* [security considerations](https://tools.ietf.org/html/draft-ietf-rtcweb-security)
* [security architecture](https://tools.ietf.org/html/draft-ietf-rtcweb-security-arch)
* [peer connection API](https://www.w3.org/TR/webrtc)
* [media capture API](https://www.w3.org/TR/mediacapture-streams)

# [JSEP.](https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-15)

JSEP(Javascript Session Establishment Protocol) описывает как использовать интерфейс [WEBRTC RTCPeerConnection](https://www.w3.org/TR/webrtc/#rtcpeerconnection-interface) для установки, управления и завршения мультимедиа сессии. JSEP позволяет полностью контролировать состояние сигнального уровня (сигнальную стейт-машину, если хотите) из Javascript. 

## Общий дизайн JSEP

Основная идея стоящая за установкой WebRTC соединения заключается в том, чтобы полностью определить и контролировать медиа-уровень, при этом оставив сингальный уровень приложению настолько, насколько это возможно. Профит в том, что разные приложения смогут выбрать различные протоколы, например SIP или Jingle, или что-то собственное, например, для реализации новых сценариев, или для упрощения встраивания WebRTC в существующую архитектуру.

Javasript Session Establishment Protocol (JSEP) максимально исключает браузер из основного потока сингалинга, который полностью контролирует Javascript через два интерфейса:

1. работа с датаграммами сессии (создание\отправка\получение\применение)
2. работа с ICE стейт-машиной

В данной спецификации JSEP описывается на примере взаимодействия двух браузеров, но на самом деле это может быть взаимодействие браузера с любой WebRTC-совместимой конечной точкой. Эта подмена незаметна для браузера, т.к. он просто следует инструкциям, получаемым через API.

Работа с датаграммами сессии в рамках JSEP проста и понятна. Когда необходим запрос\ответ обмен (offer\answer exchange) инициирующая сторона вызывает `createOffer()` API для получения нового запроса. Приложение может опционально изменить полученный запрос, а затем использовать его для настройки своей локальной конфигурации посредством `setLocalDescription()` API. После этого запрос отправляется адресату через сингальный сервер. Далее принимающая сторона получает этот запрос и настраивает удаленную конфигурацию с помощью `setRemoteDescripton()` API.

Для завершения запрос\ответ обмена принимающей стороне необходимо создать ответ с помощью `createAnswer()` API, применить его локально с помощью `setLocalDescription()` API и отправить ответ обратно инициатору через сигнальный сервер. После того как инициатор получил ответ, он устанавливает его посредствам `setRemoteDescription()` API. Начальная настройка завершена. Но этот процесс может быть повторен для дополнительных запросов\ответов.

В соответствие с ICE [RFC5245](https://tools.ietf.org/html/rfc5245), JSEP разделяет ICE стейт-машину от стейт-машины сигнального уровня (запрос\ответ обмен), ICE стейт-машина полностью управляться браузером, т.к. только браузер знает о кандидатах и обладает всей полнотой транспортной информации. Подобное разделение дает дополнительную гибкость; для протоколов отделяющих датаграммы сессии от транспорта, например Jingle, датаграмма сессии может быть отправлена сразу, а транспортная информация - когда станет доступна. Для протоколов не поддерживающих такой механизм, например SIP, информация может быть использована в аггрегированном виде. Возможность независимого обмена транспортной информацией позволяет ускорить настройку ICE и DTLS, т.к. ICE проверки могут начаться как только появится транспортная информация, не дожидаясь пока она станет доступна полностью.

Подобная абстракция сигнального уровня, означает, что приложению необходимо принимать непосредственное участие в сингальном обмене. Не смотря на то, что приложению необязательно понимать состав датаграмм сессии, чтобы начать соединение, оно должно вызывать нужные API в нужые моменты времени, а так же конвертировать датаграммы сессии и ICE информацию в сообщения выбранного сигнального протокола.

Этот процесс можно упростить, предоставив Javascript библиотеку, которая прячет всю эту сложность от разработчиков; библиотека может реализовывать конкретный сигнальный протокол вместе со стейт-машиной и сериализующим кодом, предоставляя более высокий уровень абстракции, соединение-ориентированный интерфейс для разработчика. Например, есть библиотеки адаптирующие JSEP API под SIP или XMPP. Однако, прямое использование JSEP дает больше гибкости и контроля квалифицированным разработчикам, при этом менее опытным разработчикам не придется осваивать дополнительный уровень абстракции.

## Другие рассматривавшиеся подходы.

В процессе работы над JSEP было рассмотрено несколько подходов, помимо того, который описывает JSEP. Одним из них был подход, при котором предполагалось наличие своей легковесной реализации сингального протокола, что позволило бы вместо сессионных датаграмм принимать и отправлять сообщения этого протокола. Но несмотря на то, что данный подход предоставляет более высокоуровневое API, он вынуждает браузер напрямую учавствовать в установке соединения и хранить состояние стейт-машины, на случай перезагрузки страницы.

Второй подход предполагал отделение настроек медиа-потоков от сессионных датаграмм, вместо этого предоставив API позволяющее контролировать каждую из компонент соединения отдельно, т.е. сессионную часть браузер бы брал на себя, а Javascript контролировал только media-потоки. Но этот подход был так же отвергнут, т.к. приводил к неоправданному усложению API и к гораздо более сложным сценариям работы с медиа-подсистемой на стороне клиента.

Так же рассматривался вариант, подразумевающий оставление базового датаграмма-ориентированного API, при этом убрав генерацию запросов\ответов (`createOffer\createAnswer`) из сферы ответственности браузера. Вместо этого предполагалось использовать `getCapabilities` API, предоставляющее приложению всю необходимую информацию для формирования сессионных датаграмм. Этот подход так же увеличивал сложность реализации web-приложений, т.к. ему теперь приходилось понимать сессионные датаграммами и уметь их формировать и валидировать, при этом в JSEP web-приложение чаще всего понятия не имеет что лежит в сессионных датаграммах, которыми она обменивается с другой стороной для установки соединения. Поэтому данный подход так же был отвергнут, к тому же в JSEP никто не ограничивает приложения в возможности создавать свои кастомные сессионные датаграммы, используя `createOffer\createAnswer` в качестве `getCapablilities` API, предоставляющем информацию о возможностях системы.

## Сигнальная модель.

JSEP не определяет никакую сигнальную модель или стейт-машину, кроме базового механизма обмена сессионными датаграммами, как описано в "An Offer/Answer Model with the Session Description Protocol (SDP)" [RFC3264](https://tools.ietf.org/html/rfc3264), чтобы оба участника знали как вести себя во время сессии. JSEP предоставляет механизмы создания запросов и ответов, а так же применение их к сессии. Однако, браузер исключен из механизма обмена сигнальными датаграммами. Эти задачи польностью находятся под контролем приложения, принимающего решения какие запросы\ответы и когда браузеру применять.

```

       +-----------+                               +-----------+
       |  Web App  |<--- App-Specific Signaling -->|  Web App  |
       +-----------+                               +-----------+
             ^                                            ^
             |  SDP                                       |  SDP
             V                                            V
       +-----------+                                +-----------+
       |  Browser  |<----------- Media ------------>|  Browser  |
       +-----------+                                +-----------+

```
Рис 3: Сигнальная модель JSEP. [Источник](https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-15)

### Сессионные датаграммы и стейт-машина.

Чтобы настроить медиа-уровень пользовательскому агенту нужно, понимать, что умеет принимать противоположная сторона, а так же сообщить ей, что он может принимать сам. Это осуществляется с помощью обмена сессионными датаграммами в запросах и ответах, далее будут описаны детали этого процесса.

Применение сессионной датаграммы локально или удаленно изменяет значение этой датаграммы. Например, список кодеков, отправленный противоположной стороне, описывает, что локальная сторона собирается получать, который после пересечения со списком поддерживаемых кодеков на противоположной стороне, определяет, что удаленная сторона собирается отравлять. Однако, не все параметры следуют этому правилу; например, DTLS-SRTP параметры "Framework for Establishing a Secure Real-time Transport Protocol (SRTP) and Security Context Using Datagram Transport Layer Security (DTLS)" [RFC5763](https://tools.ietf.org/html/rfc5763). Подобные параметры описывают какой сертификат локальная сторона будет использовать для DTLS, при этом противоположная сторона должна это принять, не имея возможности поменять значения параметров.

Кроме того различные RFC накладывают свои ограничения на формат запросов и ответов. Например, в запросе может быть указано произвольное множество медиа-потоков (m= секций), но ответ должен содержать ровно столько же медиа-потоков, сколько было в запросе.

Но несмотря на то, что медиа-параметры становятся известны только после завершенного запрос\ответ обмена, всегда есть возможность, для инициатора получить медиа-поток, сразу поле отправки запроса, но до получения ответа. Чтобы правильно обработать входящий медиа-поток в подобной ситуации, обарботчик медиа на инициирующей стороне должен быть в курсе деталей запроса, до того как придет ответ.

Поэтому для того, чтобы правильно работать с сессионными датаграммами пользовательский агент должен:
1. Знать чья это датаграмма (локальная или удаленная).
2. Знать является ли датаграмма запросом или ответом.
3. Позволять указать ответ независомо от вопроса.

В JSEP это реализуется с помощью предоставления методов `setLocalDescription`  и `setRemoteDescription`, плюс объекты датаграмм содержат поле `type`, где указан тип датаграммы. Это позволяет реализовать все требования приведенные выше, для обоих сторон. Инициатор сначала вызывает `setLocalDescripton(sdp[offer])`, а потом `setRemoteDescription(sdp[answer])`, адресат, же сначала вызывает `setRemoteDescription(sdp[offer])`, а потом `setLocalDescription(sdp[answer])`.

JSEP так же позволяет ответ считать предварительным на стороне приложения. Предварительные ответы предоставляют возможность ответчику, передать минимальный набор параметров, необходимых для создания сессии, при этом оставив финальный ответ на потом. Концепт финального ответа, очень важен для модели запрос\ответ; когда подобный ответ получен, все дополнительные ресурсы, аллоцированные вызывающей стороной, могут быть освобождены, т.к. точная конфигурация сессии определена. Ресурсами могут быть экстра ICE компоненты, TURN кандидаты или видео декодеры. Предварительные ответы, напротив, не приводят к освобождению ресурсов, поэтому несколько непохожих предварительных ответов, может быть получено в рамках открытия сессии.

В [RFC3264](https://tools.ietf.org/html/rfc3264) на сигнальный уровень накладывается ограничение, что для любой сессии должно быть не больше одного неотвеченного запроса, однако на уровне медиа-стека, новый запрос может быть создан в любой момент. Например, если использовать SIP для сигналинга, если один запрос отправлен, затем отменен спомощью SIP CANCEL, другой запрос может быть создан, даже если ответ на первый запрос так и не пришел. Поэтому JSEP медиа-уровень может предоставить новый запрос через `createOffer()` метод, когда бы приложение этого не пожелало. Противоположная сторона может прислать ноль или больше предварительных ответов и, наконец, завершить запрос-ответ обмен отправкой финального ответа.

Ниже приведена стейт-машина, описывающая этот процесс.

```

                       setRemote(OFFER)               setLocal(PRANSWER)
                           /-----\                               /-----\
                           |     |                               |     |
                           v     |                               v     |
            +---------------+    |                +---------------+    |
            |               |----/                |               |----/
            |               | setLocal(PRANSWER)  |               |
            |  Remote-Offer |------------------- >| Local-Pranswer|
            |               |                     |               |
            |               |                     |               |
            +---------------+                     +---------------+
                 ^   |                                   |
                 |   | setLocal(ANSWER)                  |
   setRemote(OFFER)  |                                   |
                 |   V                  setLocal(ANSWER) |
            +---------------+                            |
            |               |                            |
            |               |<---------------------------+
            |    Stable     |
            |               |<---------------------------+
            |               |                            |
            +---------------+          setRemote(ANSWER) |
                 ^   |                                   |
                 |   | setLocal(OFFER)                   |
   setRemote(ANSWER) |                                   |
                 |   V                                   |
            +---------------+                     +---------------+
            |               |                     |               |
            |               | setRemote(PRANSWER) |               |
            |  Local-Offer  |------------------- >|Remote-Pranswer|
            |               |                     |               |
            |               |----\                |               |----\
            +---------------+    |                +---------------+    |
                           ^     |                               ^     |
                           |     |                               |     |
                           \-----/                               \-----/
                       setLocal(OFFER)               setRemote(PRANSWER)

```
Рис 4: Стейт-машина JSEP. [Источник](https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-15).

На даннай диаграмме показана вся разница в обработке предворительных ответов (pranswer) и финального ответа (answer).

### Формат сессионных датаграмм.

В WebRTC сессионные датаграммы представляют из себя SDP сообщениия. Не смотря на то, что с данным форматом не так удобно работать в Javascript, он широко распространен, и часто пополяется новыми возможностями. Все альтернативные кодировки, приходилось бы держать в синхронизации с изменениями в SDP, покрайней мере до того момента, когда новая кодировки обогналабы SDP в популярности. Поэтому именно SDP используется для сессионных датаграмм JSEP.

К тому же чтобы упростить работу и предоставить гибкость в будущем SDP синтакс инкапсулирован в объекте SessionDescription, который может быть сформирован из SDP сообщения. И если последующие спецификации согласятся на использовании формата JSON для датаграмм, мы сможем легко адаптировать этот объект принимать и генерировать нужный JSON.

Другие методы могут быть добавлены в SessionDescription в будущем, чтобы упростить работу с датаграммами сессии в Javascript. Пока же сторонные Javascript библиотеки могут быть использованы для получения подобного функционала.

Обратите внимание, что в большинстве случаев приложение работает с объектами SessionDescription, как с блобами, получая их от одних методов и передавая другим, при этом вовсе нет необходимости читать их или модифицировать.

### Контроль над сессионным датаграмми.

Чтобы предоставить приложению контроль над различными сессионными параметрами, JSEP предоставляет контрольные поверхности, говорящие браузеру как создавать сессионные датаграммы. Это избавляет от необходимости менять датаграммы на стороне Javascript в большинстве случаев. Изменения этих SessionDescripton объектов приводит к изменению в сессионных датаграммах, полученных от createOffer\createAnswer методов.

### RTP-трансиверы (RtpTransceivers).

RTP-трансиверы позволяют приложению контролировать RTP-медиа, ассоциированные с одной из m= секций в сессионной датаграмме. Каждый RTP-трансивер предоставляют интерфейсы приема(RtpReceiver) и передачи(RtpSender) RTP-медиа приложению. Приложение так же может изменить RTP-трансивер напрямую, например остановить его.

Трансиверы чаще всего 1:1 соотносятся с m= секциями, но возможна ситуация, когда трансиверов создано больше, но они еще не ассоцииорованы с m= секциями, или если трансивер был остановлен и разассоциирован с m= секцией. RTP-трансивер никогда не относится к более чем к одной m= секции и как только сессионная датаграмма применена, с каждой m= секцией всегда ассоциирован только один трансивер.

Трансиверы могут быть созданы явно приложением или неявно с помощью `setRemoteDescription` и запроса, содержащего новые m= секции.

### Интерфейс отправки (RtpSenders).

Интерфейс отправки позволяет приложению контролировать как RTP-медиа отправляется. В частности, приложение может контролировать является ли интерфейс активным или нет, что отражается в атрибуте направленности (directionality attribute) соответствующей m= секции.

### Интерфейс получения (RtpReceiver).

Интерфейс получения позволяет приложению контролировать как RTP-медиа принимается. В частности, приложение может контролировать является ли интерфейс активным или нет, что отражается в аттрибуте направленности (directionlity attribute) соответствующей m= секции.

## ICE.

### Сборка.

JSEP собирает ICE кандидатов исходя их нужд приложения. Сборка ICE кандидатов называется сборочной фазой, и инициируется появлением новых или обновлением старых m= секций в локальном описании сессии, или новые ICE рекомендации(credentials) в описании, говорят о перзапуске ICE. Использование новых ICE рекомендаций(credentials) может быть инициировано приложением, или браузером в ответ на изменения в ICE конфигурации.

Когда изменения в ICE конфигурации приводят к новой сборочной фазе, взводится `needs-ice-restart` бит. Когда этот бит взведен, вызовы `createOffer` API будут создавать новые ICE рекомендации. Этот бит снимается вызовом `setLocalDescription` API с новыми ICE-рекомендациями из запроса или ответа, например при локально- или удаленно-инициированом перезапуске ICE.

Когда новая сборочная фаза начата, ICE агент уведомит приложение, что сброка в процессе по средством события (event). Затем, когда каждый новый ICE-кандидат станет доступен, ICE агент доставит его приложению с помощью дополнительного события; эти кандидаты будут так же автоматически доабвлены в текущую и ожидающие сессионные датаграммы. В завершении, когда все ICE-кандидаты будут получены, будет отправлено событие сигнализирующее о завершении сборочной фазы.

Обратите внимание, что сборочные фазы собирают кандидатов, необходимых только для новой\измененной\возобновленной\ m= секций. Другие m= секции продолжат работу с уже существующими кандидатами. Также, когда активирована группировка (bundling), кандидаты собираются и меняются только для m= секций указанный в BUNDLE-tags, как описано [здесь](https://tools.ietf.org/html/draft-ietf-mmusic-sdp-bundle-negotiation).

### Стекание ICE кандидатов (ICE Candidate Trickling).

Стекание ICE кандидатов - это техника с помощью которой инициатор может последовательно предоставлять кандидатов адресату после того, как начальный запрос был отправлен; симантика "Trickle ICE" описана [здесь](https://tools.ietf.org/html/draft-ietf-ice-trickle). Этот процесс позволяет адресату начать взаимодействие в рамках вызова, настроить ICE (и возможно DTLS) соединения немедленно, недожидаясь пока инициатор соберет всех возможных кандидатов. Это позволяет ускорить установку media-соединений, где сборка не предшествует инициированию вызова.

JSEP поддерживает опциональное стекание кандидатов предоставляя API, как описано выше, которое дает контроль над и обратную связь с процессом сборки. Приложения, которые поддерживают стекание кандидатов могут отправить первоначальный запрос сразу и отправлять отдельных кандидатов, как только они будут готовы, реагируя на соотв. оповещения. Приложения не поддерживающие подобный функционал должны просто дождаться завешения сборочной фазы и после этого создать и отправить запрос со всеми доступными кандидатами одновременно.

При получении такого кандидата, принимающее приложение отдает его своему ICE агенту. Это заставляет ICE агента использовать нового кандидата для проверки соединения.

### Формат ICE кандидата.

Как и с описаниями сессии, IceCandidate объект предоставляет некую абстракцию, но может быть легко сконвертирован в форму строки SDP-кандидата.

Стока кандидата - это вся SDP информация, которую содержит IceCandidate. Вот пример строки кандидата:

```
candidate:1 1 UDP 1694498815 192.0.2.33 10000 typ host

```
IceCandidate также содержит поля указывающие с какой m= строкой он должен быть ассоциирован одним из двух способов: или с помощью индекса m= строки, или с помощью MID. Индекс m= строки - это число от нуля до кол-ва m= строк минус один (N-1). MID использует "media stream identification" аттрибут, как описано в [RFC5888](https://tools.ietf.org/html/rfc5888). Реализации JSEP должны поддерживать оба этих поля. Реализации, принимающие ICE кандидатов, должны в первую очередь использовать MID, и только при его отсутствии - индекс m= строки.

### Политики ICE кандидатов.

Обычно, когда собираются ICE кандидаты, браузер собирает все возможные формы из первоначальных кандидатов - хост, возвратный сервер или реле. Однако, в некоторых случаях, приложения могут захотеть больше контроля над процессом сборки, из соображений безопасности и т.д. Например, можно запретить использование хост-кандидатов, чтобы предотвратить раскрытие информации о локальной сети, или пойти еще дальше, разрешив использовать только релейные сервера, чтобы свести к минимуму возможность утечки локальной информации, при этом нужно помнить, что подобные ограничения приводят к повышенной стоимости этих операций. В целом браузер при необходимости должен предоставить приложению возможность явно указать какими кандидатами пользоваться во время сессии. Обратите внимание, что эта фильтрация применяется над всеми ограничениями, использующимися браузером при определении, какие адреса разрешены для приложения, как описано [здесь](https://tools.ietf.org/html/draft-ietf-rtcweb-ip-handling).

Так же могут быть случаи, когда приложение хочет изменить тип кандидатов во время активной сессии. Простой пример, когда звонящий первоначально хотел использовать релейных кандидатов, чтобы предотвратить утечку локальной информации неизвестному звонящему, но потом выбрал использовать всех кандидатов, для ускорения работы, когда был уведомлен, что они нужны, чтобы принять звонок. Для этого сценария браузер должен изменение политики кандидатов при активной сессии.

Чтобы управлять политикой ICE кандидатов, браузер должен определить текущую настройку при старте каждой сборочной фазы. Тогда в течение сборочной фазы, браузер не должен предоставлять кандидатов запрещенных текущей политикой приложения, использовать их как источник для комунникационных проверок, или неявно выдавать их в других полях, таких как raddr\saddr атрибутов для других ICE кандидатов.

### Пул ICE-кандидатов.

JSEP приложения обычно инициируют браузер начать ICE сборку посредством информации отправляемой через `setLocalDescription`, т.к. именно в этот момент приложение определяет количество медиа потоков и тем самым ICE компоненты, для которых собирать кандидатов. Однако, чтобы ускорить случаи, когда приложение знает несколько ICE компонент, еще до того, как они понадобятся, тогда оно может попросить браузер держать пул потенциальных ICE кандидатов, чтобы гарантировать быструю настройку соединения.

Когда `setLocalDescription` вызван, браузер начинает собирать необходимых ICE кандидатов, он должен начать с кандидатов из пула. Если кандидаты есть, они возвращаются приложению немедленно, посредством оповещения об ICE кандидате. Если пул истощается, в результате большего чем ожидалось количества компонент, или по причине того, что пул еще не успел заполнится, так или иначе недостающие кандидаты будут собраны как обычно.

Примером того, где этот концепт применим является приложение, которое ожидает входящий вызов в какой-то конкретный момент времени в будущем, и хочет минимизировать время на установку соединения, чтобы минимизировать потерю первоначального медиа. Посредством собирания ICE кандидатов в пул, можно инициировать настройку соединения на этих кандадатах сразу после получение вызова. Однако, не стоит забывать, что хранение пресобранных кандидатов, которые остаются живыми, пока они нужны приложению, занимает ресурсы на STUN\TURN серверах, которые использует приложение.

## Согласование размеров видео.

Согласование размеров видео - это процесс с помощью которого получатель может использовать `a=imagearrt` SDP атрибут [RFC6236](https://tools.ietf.org/html/rfc6236), чтобы указать какой размер видео фрейма он способен принимать. Принимающая сторона может быть ограничена в пределами видео-декодера, или оно это нужно приложению, например специфичный размер окна, в котором видео будет показано.

### Создание imageattr аттрибута.

Чтобы определить возможное для принимающей стороны разрешение видео, пересекаются лимиты декодера с обязательными ограничениями, которые применяются к MediaStreamTrack объекту. Если лимиты декодаре неизвестны, например когда используется программных декодер, используются только обязательные ограничения. Для ответчика эти обязательные ограничения могут быть применены к удаленному MediaStreamTrack, который получен при вызове setRemoteDescription и повлияют на ответ от подтверждающего createAnswer вызова. Любые ограничение наложенные после использования setLocalDescription для настройки ответа, приведут к новому запрос\ответ обмену. Инициатор, т.к. он не знает о каких удаленных MedisStreamTrack объектах, пока он не получит ответ, может только отразить пределы декодера. Если инициатор желает наложить обязательные ограничения на разрешение видео, он должен сделать это после получения ответа и результатом будет новый запрос\ответ обмен.

Если нет никаких известных ограничений декодера или обязательных ограничений, атрибут imageattr должен быть опущен.

<- RFC
3.2.  Session Descriptions and State Machine
3.3.  Session Description Format
3.4.  Session Description Control
3.4.1.  RtpTransceivers
3.4.2.  RtpSenders
3.4.3.  RtpReceivers
3.5.  ICE
3.5.2.  ICE Candidate Trickling
3.5.2.1.  ICE Candidate Format
3.5.3.  ICE Candidate Policy
3.5.4.  ICE Candidate Pool
3.6.  Video Size Negotiation
3.6.1.  Creating an imageattr Attribute

   Otherwise, an "a=imageattr" attribute is created with "recv"
   direction, and the resulting resolution space formed by intersecting
   the decoder limits and constraints is used to specify its minimum and
   maximum x= and y= values.  If the intersection is the null set, i.e.,
   there are no resolutions that are permitted by both the decoder and
   the mandatory constraints, this SHOULD be represented by x=0 and y=0
   values.

   The rules here express a single set of preferences, and therefore,
   the "a=imageattr" q= value is not important.  It SHOULD be set to
   1.0.

   The "a=imageattr" field is payload type specific.  When all video
   codecs supported have the same capabilities, use of a single
   attribute, with the wildcard payload type (*), is RECOMMENDED.
   However, when the supported video codecs have differing capabilities,
   specific "a=imageattr" attributes MUST be inserted for each payload
   type.

   As an example, consider a system with a HD-capable, multiformat video
   decoder, where the application has constrained the received track to
   at most 360p.  In this case, the implementation would generate this
   attribute:

   a=imageattr:* recv [x=[16:640],y=[16:360],q=1.0]

   This declaration indicates that the receiver is capable of decoding
   any image resolution from 16x16 up to 640x360 pixels.

3.6.2.  Interpreting an imageattr Attribute

   [RFC6236] defines "a=imageattr" to be an advisory field.  This means
   that it does not absolutely constrain the video formats that the
   sender can use, but gives an indication of the preferred values.

   This specification prescribes more specific behavior.  When a sender
   of a given MediaStreamTrack, which is producing video of a certain
   resolution, receives an "a=imageattr recv" attribute, it MUST check
   to see if the original resolution meets the size criteria specified
   in the attribute, and adapt the resolution accordingly by scaling (if
   appropriate).  Note that when considering a MediaStreamTrack that is
   producing rotated video, the unrotated resolution MUST be used.  This
   is required regardless of whether the receiver supports performing
   receive-side rotation (e.g., through CVO), as it significantly
   simplifies the matching logic.

   For an "a=imageattr recv" attribute, only size limits are considered.
   Any other values, e.g.  aspect ratio, MUST be ignored.

   When communicating with a non-JSEP endpoint, multiple relevant
   "a=imageattr recv" attributes may be received.  If this occurs,
   attributes other than the one with the highest "q=" value MUST be
   ignored.

   If an "a=imageattr recv" attribute references a different video codec
   than what has been selected for the MediaStreamTrack, it MUST be
   ignored.

   If the original resolution matches the size limits in the attribute,
   the track MUST be transmitted untouched.

   If the original resolution exceeds the size limits in the attribute,
   the sender SHOULD apply downscaling to the output of the
   MediaStreamTrack in order to satisfy the limits.  Downscaling MUST
   NOT change the track aspect ratio.

   If the original resolution is less than the size limits in the
   attribute, upscaling is needed, but this may not be appropriate in
   all cases.  To address this concern, the application can set an
   upscaling policy for each sent track.  For this case, if upscaling is
   permitted by policy, the sender SHOULD apply upscaling in order to
   provide the desired resolution.  Otherwise, the sender MUST NOT apply
   upscaling.  The sender SHOULD NOT upscale in other cases, even if the
   policy permits it.  Upscaling MUST NOT change the track aspect ratio.
   If there is no appropriate and permitted scaling mechanism that
   allows the received size limits to be satisfied, the sender MUST NOT
   transmit the track.

   In the special case of receiving a maximum resolution of [0, 0], as
   described above, the sender MUST NOT transmit the track.

3.7.  Interactions With Forking

   Some call signaling systems allow various types of forking where an
   SDP Offer may be provided to more than one device.  For example, SIP
   [RFC3261] defines both a "Parallel Search" and "Sequential Search".
   Although these are primarily signaling level issues that are outside
   the scope of JSEP, they do have some impact on the configuration of
   the media plane that is relevant.  When forking happens at the
   signaling layer, the Javascript application responsible for the
   signaling needs to make the decisions about what media should be sent
   or received at any point of time, as well as which remote endpoint it
   should communicate with; JSEP is used to make sure the media engine
   can make the RTP and media perform as required by the application.
   The basic operations that the applications can have the media engine
   do are:

   o  Start exchanging media with a given remote peer, but keep all the
      resources reserved in the offer.

   o  Start exchanging media with a given remote peer, and free any
      resources in the offer that are not being used.

3.7.1.  Sequential Forking

   Sequential forking involves a call being dispatched to multiple
   remote callees, where each callee can accept the call, but only one
   active session ever exists at a time; no mixing of received media is
   performed.

   JSEP handles sequential forking well, allowing the application to
   easily control the policy for selecting the desired remote endpoint.
   When an answer arrives from one of the callees, the application can
   choose to apply it either as a provisional answer, leaving open the
   possibility of using a different answer in the future, or apply it as
   a final answer, ending the setup flow.

   In a "first-one-wins" situation, the first answer will be applied as
   a final answer, and the application will reject any subsequent
   answers.  In SIP parlance, this would be ACK + BYE.
   In a "last-one-wins" situation, all answers would be applied as
   provisional answers, and any previous call leg will be terminated.
   At some point, the application will end the setup process, perhaps
   with a timer; at this point, the application could reapply the
   pending remote description as a final answer.

3.7.2.  Parallel Forking

   Parallel forking involves a call being dispatched to multiple remote
   callees, where each callee can accept the call, and multiple
   simultaneous active signaling sessions can be established as a
   result.  If multiple callees send media at the same time, the
   possibilities for handling this are described in Section 3.1 of
   [RFC3960].  Most SIP devices today only support exchanging media with
   a single device at a time, and do not try to mix multiple early media
   audio sources, as that could result in a confusing situation.  For
   example, consider having a European ringback tone mixed together with
   the North American ringback tone - the resulting sound would not be
   like either tone, and would confuse the user.  If the signaling
   application wishes to only exchange media with one of the remote
   endpoints at a time, then from a media engine point of view, this is
   exactly like the sequential forking case.

   In the parallel forking case where the Javascript application wishes
   to simultaneously exchange media with multiple peers, the flow is
   slightly more complex, but the Javascript application can follow the
   strategy that [RFC3960] describes using UPDATE.  The UPDATE approach
   allows the signaling to set up a separate media flow for each peer
   that it wishes to exchange media with.  In JSEP, this offer used in
   the UPDATE would be formed by simply creating a new PeerConnection
   and making sure that the same local media streams have been added
   into this new PeerConnection.  Then the new PeerConnection object
   would produce a SDP offer that could be used by the signaling to
   perform the UPDATE strategy discussed in [RFC3960].

   As a result of sharing the media streams, the application will end up
   with N parallel PeerConnection sessions, each with a local and remote
   description and their own local and remote addresses.  The media flow
   from these sessions can be managed by specifying SDP direction
   attributes in the descriptions, or the application can choose to play
   out the media from all sessions mixed together.  Of course, if the
   application wants to only keep a single session, it can simply
   terminate the sessions that it no longer needs.

4.  Interface

   This section details the basic operations that must be present to
   implement JSEP functionality.  The actual API exposed in the W3C API
   may have somewhat different syntax, but should map easily to these
   concepts.

4.1.  Methods

4.1.1.  Constructor

   The PeerConnection constructor allows the application to specify
   global parameters for the media session, such as the STUN/TURN
   servers and credentials to use when gathering candidates, as well as
   the initial ICE candidate policy and pool size, and also the bundle
   policy to use.

   If an ICE candidate policy is specified, it functions as described in
   Section 3.5.3, causing the browser to only surface the permitted
   candidates (including any internal browser filtering) to the
   application, and only use those candidates for connectivity checks.
   The set of available policies is as follows:

   all:  All candidates permitted by browser policy will be gathered and
      used.



   relay:  All candidates except relay candidates will be filtered out.
      This obfuscates the location information that might be ascertained
      by the remote peer from the received candidates.  Depending on how
      the application deploys its relay servers, this could obfuscate
      location to a metro or possibly even global level.

   The default ICE candidate policy MUST be set to "all" as this is
   generally the desired policy, and also typically reduces use of
   application TURN server resources significantly.

   If a size is specified for the ICE candidate pool, this indicates the
   number of ICE components to pre-gather candidates for.  Because pre-
   gathering results in utilizing STUN/TURN server resources for
   potentially long periods of time, this must only occur upon
   application request, and therefore the default candidate pool size
   MUST be zero.

   The application can specify its preferred policy regarding use of
   bundle, the multiplexing mechanism defined in
   [I-D.ietf-mmusic-sdp-bundle-negotiation].  Regardless of policy, the
   application will always try to negotiate bundle onto a single
   transport, and will offer a single bundle group across all media
   section; use of this single transport is contingent upon the answerer
   accepting bundle.  However, by specifying a policy from the list
   below, the application can control exactly how aggressively it will
   try to bundle media streams together, which affects how it will
   interoperate with a non-bundle-aware endpoint.  When negotiating with
   a non-bundle-aware endpoint, only the streams not marked as bundle-
   only streams will be established.

   The set of available policies is as follows:

   balanced:  The first media section of each type (audio, video, or
      application) will contain transport parameters, which will allow
      an answerer to unbundle that section.  The second and any
      subsequent media section of each type will be marked bundle-only.
      The result is that if there are N distinct media types, then
      candidates will be gathered for for N media streams.  This policy
      balances desire to multiplex with the need to ensure basic audio
      and video can still be negotiated in legacy cases.  When acting as
      answerer, if there is no bundle group in the offer, the
      implementation will reject all but the first m= section of each
      type.



   max-compat:  All media sections will contain transport parameters;
      none will be marked as bundle-only.  This policy will allow all
      streams to be received by non-bundle-aware endpoints, but require
      separate candidates to be gathered for each media stream.



   max-bundle:  Only the first media section will contain transport
      parameters; all streams other than the first will be marked as
      bundle-only.  This policy aims to minimize candidate gathering and
      maximize multiplexing, at the cost of less compatibility with
      legacy endpoints.  When acting as answerer, if there if no bundle
      group in the offer, the implementation will reject all but the
      first m= section.

   As it provides the best tradeoff between performance and
   compatibility with legacy endpoints, the default bundle policy MUST
   be set to "balanced".

   The application can specify its preferred policy regarding use of
   RTP/RTCP multiplexing [RFC5761] using one of the following policies:

   negotiate:  The browser will gather both RTP and RTCP candidates but
      also will offer "a=rtcp-mux", thus allowing for compatibility with
      either multiplexing or non-multiplexing endpoints.

   require:  The browser will only gather RTP candidates.  This halves
      the number of candidates that the offerer needs to gather.  When
      acting as answerer, the implementation will reject any m= section
      that does not contain an "a=rtcp-mux" attribute.

   The default multiplexing policy MUST be set to "require".
   Implementations MAY choose to reject attempts by the application to
   set the multiplexing policy to "negotiate".

4.1.2.  addTrack

   The addTrack method adds a MediaStreamTrack to the PeerConnection,
   using the MediaStream argument to associate the track with other
   tracks in the same MediaStream, so that they can be added to the same
   "LS" group when creating an offer or answer.  addTrack attempts to
   minimize the number of transceivers as follows: The track will be
   attached to the first compatible transceiver (of the same media type)
   which has never had a direction of "sendonly" or "sendrecv".  If no
   such transceiver exists, then one will be constructed as described in
   Section 4.1.3.

4.1.3.  addTransceiver

   [TODO]

4.1.4.  createDataChannel

   [TODO]

4.1.5.  createOffer

   The createOffer method generates a blob of SDP that contains a
   [RFC3264] offer with the supported configurations for the session,
   including descriptions of the media added to this PeerConnection, the
   codec/RTP/RTCP options supported by this implementation, and any
   candidates that have been gathered by the ICE Agent.  An options
   parameter may be supplied to provide additional control over the
   generated offer.  This options parameter allows an application to
   trigger an ICE restart, for the purpose of reestablishing
   connectivity.

   In the initial offer, the generated SDP will contain all desired
   functionality for the session (functionality that is supported but
   not desired by default may be omitted); for each SDP line, the
   generation of the SDP will follow the process defined for generating
   an initial offer from the document that specifies the given SDP line.
   The exact handling of initial offer generation is detailed in
   Section 5.2.1 below.

   In the event createOffer is called after the session is established,
   createOffer will generate an offer to modify the current session
   based on any changes that have been made to the session, e.g., adding
   or stopping RtpTransceivers, or requesting an ICE restart.  For each
   existing stream, the generation of each SDP line must follow the
   process defined for generating an updated offer from the RFC that
   specifies the given SDP line.  For each new stream, the generation of
   the SDP must follow the process of generating an initial offer, as
   mentioned above.  If no changes have been made, or for SDP lines that
   are unaffected by the requested changes, the offer will only contain
   the parameters negotiated by the last offer-answer exchange.  The
   exact handling of subsequent offer generation is detailed in
   Section 5.2.2. below.

   Session descriptions generated by createOffer must be immediately
   usable by setLocalDescription; if a system has limited resources
   (e.g. a finite number of decoders), createOffer should return an
   offer that reflects the current state of the system, so that
   setLocalDescription will succeed when it attempts to acquire those
   resources.  Because this method may need to inspect the system state
   to determine the currently available resources, it may be implemented
   as an async operation.

   Calling this method may do things such as generate new ICE
   credentials, but does not result in candidate gathering, or cause
   media to start or stop flowing.

4.1.6.  createAnswer

   The createAnswer method generates a blob of SDP that contains a
   [RFC3264] SDP answer with the supported configuration for the session
   that is compatible with the parameters supplied in the most recent
   call to setRemoteDescription, which MUST have been called prior to
   calling createAnswer.  Like createOffer, the returned blob contains
   descriptions of the media added to this PeerConnection, the
   codec/RTP/RTCP options negotiated for this session, and any
   candidates that have been gathered by the ICE Agent.  An options
   parameter may be supplied to provide additional control over the
   generated answer.

   As an answer, the generated SDP will contain a specific configuration
   that specifies how the media plane should be established; for each
   SDP line, the generation of the SDP must follow the process defined
   for generating an answer from the document that specifies the given
   SDP line.  The exact handling of answer generation is detailed in
   Section 5.3.  below.

   Session descriptions generated by createAnswer must be immediately
   usable by setLocalDescription; like createOffer, the returned
   description should reflect the current state of the system.  Because
   this method may need to inspect the system state to determine the
   currently available resources, it may need to be implemented as an
   async operation.

   Calling this method may do things such as generate new ICE
   credentials, but does not trigger candidate gathering or change media
   state.

4.1.7.  SessionDescriptionType

   Session description objects (RTCSessionDescription) may be of type
   "offer", "pranswer", "answer" or "rollback".  These types provide
   information as to how the description parameter should be parsed, and
   how the media state should be changed.

   "offer" indicates that a description should be parsed as an offer;
   said description may include many possible media configurations.  A
   description used as an "offer" may be applied anytime the
   PeerConnection is in a stable state, or as an update to a previously
   supplied but unanswered "offer".

   "pranswer" indicates that a description should be parsed as an
   answer, but not a final answer, and so should not result in the
   freeing of allocated resources.  It may result in the start of media
   transmission, if the answer does not specify an inactive media
   direction.  A description used as a "pranswer" may be applied as a
   response to an "offer", or an update to a previously sent "pranswer".

   "answer" indicates that a description should be parsed as an answer,
   the offer-answer exchange should be considered complete, and any
   resources (decoders, candidates) that are no longer needed can be
   released.  A description used as an "answer" may be applied as a
   response to an "offer", or an update to a previously sent "pranswer".

   The only difference between a provisional and final answer is that
   the final answer results in the freeing of any unused resources that
   were allocated as a result of the offer.  As such, the application
   can use some discretion on whether an answer should be applied as
   provisional or final, and can change the type of the session
   description as needed.  For example, in a serial forking scenario, an
   application may receive multiple "final" answers, one from each
   remote endpoint.  The application could choose to accept the initial
   answers as provisional answers, and only apply an answer as final
   when it receives one that meets its criteria (e.g. a live user
   instead of voicemail).

   "rollback" is a special session description type implying that the
   state machine should be rolled back to the previous state, as
   described in Section 4.1.7.2.  The contents MUST be empty.

4.1.7.1.  Use of Provisional Answers

   Most web applications will not need to create answers using the
   "pranswer" type.  While it is good practice to send an immediate
   response to an "offer", in order to warm up the session transport and
   prevent media clipping, the preferred handling for a web application
   would be to create and send an "inactive" final answer immediately
   after receiving the offer.  Later, when the called user actually
   accepts the call, the application can create a new "sendrecv" offer
   to update the previous offer/answer pair and start the media flow.
   While this could also be done with an inactive "pranswer", followed
   by a sendrecv "answer", the initial "pranswer" leaves the offer-
   answer exchange open, which means that neither side can send an
   updated offer during this time.

   As an example, consider a typical web application that will set up a
   data channel, an audio channel, and a video channel.  When an
   endpoint receives an offer with these channels, it could send an
   answer accepting the data channel for two-way data, and accepting the
   audio and video tracks as inactive or receive-only.  It could then
   ask the user to accept the call, acquire the local media streams, and
   send a new offer to the remote side moving the audio and video to be
   two-way media.  By the time the human has accepted the call and
   triggered the new offer, it is likely that the ICE and DTLS
   handshaking for all the channels will already have finished.

   Of course, some applications may not be able to perform this double
   offer-answer exchange, particularly ones that are attempting to
   gateway to legacy signaling protocols.  In these cases, "pranswer"
   can still provide the application with a mechanism to warm up the
   transport.

4.1.7.2.  Rollback

   In certain situations it may be desirable to "undo" a change made to
   setLocalDescription or setRemoteDescription.  Consider a case where a
   call is ongoing, and one side wants to change some of the session
   parameters; that side generates an updated offer and then calls
   setLocalDescription.  However, the remote side, either before or
   after setRemoteDescription, decides it does not want to accept the
   new parameters, and sends a reject message back to the offerer.  Now,
   the offerer, and possibly the answerer as well, need to return to a
   stable state and the previous local/remote description.  To support
   this, we introduce the concept of "rollback".

   A rollback discards any proposed changes to the session, returning
   the state machine to the stable state, and setting the pending local
   and/or remote description back to null.  Any resources or candidates
   that were allocated by the abandoned local description are discarded;
   any media that is received will be processed according to the
   previous local and remote descriptions.  Rollback can only be used to
   cancel proposed changes; there is no support for rolling back from a
   stable state to a previous stable state.  Note that this implies that
   once the answerer has performed setLocalDescription with his answer,
   this cannot be rolled back.

   A rollback will disassociate any RtpTransceivers that were associated
   with m= sections by the application of the rolled-back session
   description (see Section 5.8 and Section 5.7).  This means that some
   RtpTransceivers that were previously associated will no longer be
   associated with any m= section; in such cases, the value of the
   RtpTransceiver's mid attribute MUST be set to null.  RtpTransceivers
   that were created by applying a remote offer that was subsequently
   rolled back MUST be removed.  However, a RtpTransceiver MUST NOT be
   removed if the RtpTransceiver's RtpSender was activated by the
   addTrack method.  This is so that an application may call addTrack,
   then call setRemoteDescription with an offer, then roll back that
   offer, then call createOffer and have a m= section for the added
   track appear in the generated offer.

   A rollback is performed by supplying a session description of type
   "rollback" with empty contents to either setLocalDescription or
   setRemoteDescription, depending on which was most recently used (i.e.
   if the new offer was supplied to setLocalDescription, the rollback
   should be done using setLocalDescription as well).

4.1.8.  setLocalDescription

   The setLocalDescription method instructs the PeerConnection to apply
   the supplied session description as its local configuration.  The
   type field indicates whether the description should be processed as
   an offer, provisional answer, or final answer; offers and answers are
   checked differently, using the various rules that exist for each SDP
   line.

   This API changes the local media state; among other things, it sets
   up local resources for receiving and decoding media.  In order to
   successfully handle scenarios where the application wants to offer to
   change from one media format to a different, incompatible format, the
   PeerConnection must be able to simultaneously support use of both the
   current and pending local descriptions (e.g.  support codecs that
   exist in both descriptions) until a final answer is received, at
   which point the PeerConnection can fully adopt the pending local
   description, or roll back to the current description if the remote
   side denied the change.

   This API indirectly controls the candidate gathering process.  When a
   local description is supplied, and the number of transports currently
   in use does not match the number of transports needed by the local
   description, the PeerConnection will create transports as needed and
   begin gathering candidates for them.

   If setRemoteDescription was previously called with an offer, and
   setLocalDescription is called with an answer (provisional or final),
   and the media directions are compatible, and media are available to
   send, this will result in the starting of media transmission.

4.1.9.  setRemoteDescription

   The setRemoteDescription method instructs the PeerConnection to apply
   the supplied session description as the desired remote configuration.
   As in setLocalDescription, the type field of the description
   indicates how it should be processed.

   This API changes the local media state; among other things, it sets
   up local resources for sending and encoding media.

   If setLocalDescription was previously called with an offer, and
   setRemoteDescription is called with an answer (provisional or final),
   and the media directions are compatible, and media are available to
   send, this will result in the starting of media transmission.

4.1.10.  currentLocalDescription

   The currentLocalDescription method returns a copy of the current
   negotiated local description - i.e., the local description from the
   last successful offer/answer exchange - in addition to any local
   candidates that have been generated by the ICE Agent since the local
   description was set.

   A null object will be returned if an offer/answer exchange has not
   yet been completed.

4.1.11.  pendingLocalDescription

   The pendingLocalDescription method returns a copy of the local
   description currently in negotiation - i.e., a local offer set
   without any corresponding remote answer - in addition to any local
   candidates that have been generated by the ICE Agent since the local
   description was set.

   A null object will be returned if the state of the PeerConnection is
   "stable" or "have-remote-offer".

4.1.12.  currentRemoteDescription

   The currentRemoteDescription method returns a copy of the current
   negotiated remote description - i.e., the remote description from the
   last successful offer/answer exchange - in addition to any remote
   candidates that have been supplied via processIceMessage since the
   remote description was set.

   A null object will be returned if an offer/answer exchange has not
   yet been completed.

4.1.13.  pendingRemoteDescription

   The pendingRemoteDescription method returns a copy of the remote
   description currently in negotiation - i.e., a remote offer set
   without any corresponding local answer - in addition to any remote
   candidates that have been supplied via processIceMessage since the
   remote description was set.

   A null object will be returned if the state of the PeerConnection is
   "stable" or "have-local-offer".

4.1.14.  canTrickleIceCandidates

   The canTrickleIceCandidates property indicates whether the remote
   side supports receiving trickled candidates.  There are three
   potential values:

   null:  No SDP has been received from the other side, so it is not
      known if it can handle trickle.  This is the initial value before
      setRemoteDescription() is called.

   true:  SDP has been received from the other side indicating that it
      can support trickle.

   false:  SDP has been received from the other side indicating that it


   As described in Section 3.5.2, JSEP implementations always provide
   candidates to the application individually, consistent with what is
   needed for Trickle ICE.  However, applications can use the
   canTrickleIceCandidates property to determine whether their peer can
   actually do Trickle ICE, i.e., whether it is safe to send an initial
   offer or answer followed later by candidates as they are gathered.
   As "true" is the only value that definitively indicates remote
   Trickle ICE support, an application which compares
   canTrickleIceCandidates against "true" will by default attempt Half
   Trickle on initial offers and Full Trickle on subsequent interactions
   with a Trickle ICE-compatible agent.

4.1.15.  setConfiguration

   The setConfiguration method allows the global configuration of the
   PeerConnection, which was initially set by constructor parameters, to
   be changed during the session.  The effects of this method call
   depend on when it is invoked, and differ depending on which specific
   parameters are changed:

   o  Any changes to the STUN/TURN servers to use affect the next
      gathering phase.  If an ICE gathering phase has already started or
      completed, the 'needs-ice-restart' bit mentioned in Section 3.5.1
      will be set.  This will cause the next call to createOffer to
      generate new ICE credentials, for the purpose of forcing an ICE
      restart and kicking off a new gathering phase, in which the new
      servers will be used.  If the ICE candidate pool has a nonzero
      size, any existing candidates will be discarded, and new
      candidates will be gathered from the new servers.

   o  Any change to the ICE candidate policy affects the next gathering
      phase.  If an ICE gathering phase has already started or
      completed, the 'needs-ice-restart' bit will be set.  Either way,
      changes to the policy have no effect on the candidate pool,
      because pooled candidates are not surfaced to the application
      until a gathering phase occurs, and so any necessary filtering can
      still be done on any pooled candidates.

   o  Any changes to the ICE candidate pool size take effect
      immediately; if increased, additional candidates are pre-gathered;
      if decreased, the now-superfluous candidates are discarded.

   o  The bundle and RTCP-multiplexing policies MUST NOT be changed
      after the construction of the PeerConnection.

   This call may result in a change to the state of the ICE Agent, and
   may result in a change to media state if it results in connectivity


4.1.16.  addIceCandidate

   The addIceCandidate method provides a remote candidate to the ICE
   Agent, which, if parsed successfully, will be added to the current
   and/or pending remote description according to the rules defined for
   Trickle ICE.  If the MID, m-line index, or candidate string provided
   in the ICE candidate is invalid, an error is generated.  Connectivity
   checks will be sent to the new candidate.

   This method can also be used to provide an end-of-candidates
   indication (as defined in [I-D.ietf-ice-trickle]) to the ICE Agent
   for all media descriptions in the last remote description.

   This call will result in a change to the state of the ICE Agent, and
   may result in a change to media state if it results in connectivity
   being established.

5.  SDP Interaction Procedures

   This section describes the specific procedures to be followed when
   creating and parsing SDP objects.

5.1.  Requirements Overview

   JSEP implementations must comply with the specifications listed below
   that govern the creation and processing of offers and answers.

   The first set of specifications is the "mandatory-to-implement" set.
   All implementations must support these behaviors, but may not use all
   of them if the remote side, which may not be a JSEP endpoint, does
   not support them.

   The second set of specifications is the "mandatory-to-use" set.  The
   local JSEP endpoint and any remote endpoint must indicate support for
   these specifications in their session descriptions.

5.1.1.  Implementation Requirements

   This list of mandatory-to-implement specifications is derived from
   the requirements outlined in [I-D.ietf-rtcweb-rtp-usage].

   R-1   [RFC4566] is the base SDP specification and MUST be
         implemented.

   R-2   [RFC5764] MUST be supported for signaling the UDP/TLS/RTP/SAVPF
         [RFC5764], TCP/DTLS/RTP/SAVPF
         [I-D.nandakumar-mmusic-proto-iana-registration], "UDP/DTLS/


         SCTP" [I-D.ietf-mmusic-sctp-sdp], and "TCP/DTLS/SCTP"
         [I-D.ietf-mmusic-sctp-sdp] RTP profiles.

   R-3   [RFC5245] MUST be implemented for signaling the ICE credentials
         and candidate lines corresponding to each media stream.  The
         ICE implementation MUST be a Full implementation, not a Lite
         implementation.

   R-4   [RFC5763] MUST be implemented to signal DTLS certificate
         fingerprints.

   R-5   [RFC4568] MUST NOT be implemented to signal SDES SRTP keying
         information.

   R-6   The [RFC5888] grouping framework MUST be implemented for
         signaling grouping information, and MUST be used to identify m=
         lines via the a=mid attribute.

   R-7   [I-D.ietf-mmusic-msid] MUST be supported, in order to signal
         associations between RTP objects and W3C MediaStreams and
         MediaStreamTracks in a standard way.

   R-8   The bundle mechanism in
         [I-D.ietf-mmusic-sdp-bundle-negotiation] MUST be supported to
         signal the ability to multiplex RTP streams on a single UDP
         port, in order to avoid excessive use of port number resources.

   R-9   The SDP attributes of "sendonly", "recvonly", "inactive", and
         "sendrecv" from [RFC4566] MUST be implemented to signal
         information about media direction.

   R-10  [RFC5576] MUST be implemented to signal RTP SSRC values and
         grouping semantics.

   R-11  [RFC4585] MUST be implemented to signal RTCP based feedback.

   R-12  [RFC5761] MUST be implemented to signal multiplexing of RTP and
         RTCP.

   R-13  [RFC5506] MUST be implemented to signal reduced-size RTCP
         messages.

   R-14  [RFC4588] MUST be implemented to signal RTX payload type
         associations.

   R-15  [RFC3556] with bandwidth modifiers MAY be supported for
         specifying RTCP bandwidth as a fraction of the media bandwidth,


         RTCP fraction allocated to the senders and setting maximum
         media bit-rate boundaries.

   R-16  TODO: any others?

   As required by [RFC4566], Section 5.13, JSEP implementations MUST
   ignore unknown attribute (a=) lines.

5.1.2.  Usage Requirements

   All session descriptions handled by JSEP endpoints, both local and
   remote, MUST indicate support for the following specifications.  If
   any of these are absent, this omission MUST be treated as an error.

   R-1  ICE, as specified in [RFC5245], MUST be used.  Note that the
        remote endpoint may use a Lite implementation; implementations
        MUST properly handle remote endpoints which do ICE-Lite.

   R-2  DTLS [RFC6347] or DTLS-SRTP [RFC5763], MUST be used, as
        appropriate for the media type, as specified in
        [I-D.ietf-rtcweb-security-arch]

5.1.3.  Profile Names and Interoperability

   For media m= sections, JSEP endpoints MUST support both the "UDP/TLS/
   RTP/SAVPF" and "TCP/DTLS/RTP/SAVPF" profiles and MUST indicate one of
   these two profiles for each media m= line they produce in an offer.
   For data m= sections, JSEP endpoints must support both the "UDP/DTLS/
   SCTP" and "TCP/DTLS/SCTP" profiles and MUST indicate one of these two
   profiles for each data m= line they produce in an offer.  Because ICE
   can select either TCP or UDP transport depending on network
   conditions, both advertisements are consistent with ICE eventually
   selecting either either UDP or TCP.

   Unfortunately, in an attempt at compatibility, some endpoints
   generate other profile strings even when they mean to support one of
   these profiles.  For instance, an endpoint might generate "RTP/AVP"
   but supply "a=fingerprint" and "a=rtcp-fb" attributes, indicating its
   willingness to support "(UDP,TCP)/TLS/RTP/SAVPF".  In order to
   simplify compatibility with such endpoints, JSEP endpoints MUST
   follow the following rules when processing the media m= sections in
   an offer:

   o  The profile in any "m=" line in any answer MUST exactly match the
      profile provided in the offer.

   o  Any profile matching the following patterns MUST be accepted:


   o  Because DTLS-SRTP is REQUIRED, the choice of SAVP or AVP has no
      effect; support for DTLS-SRTP is determined by the presence of one
      or more "a=fingerprint" attribute.  Note that lack of an
      "a=fingerprint" attribute will lead to negotiation failure.

   o  The use of AVPF or AVP simply controls the timing rules used for
      RTCP feedback.  If AVPF is provided, or an "a=rtcp-fb" attribute
      is present, assume AVPF timing, i.e. a default value of "trr-
      int=0".  Otherwise, assume that AVPF is being used in an AVP
      compatible mode and use AVP timing, i.e., "trr-int=4".

   o  For data m= sections, JSEP endpoints MUST support receiving the
      "UDP/ DTLS/SCTP", "TCP/DTLS/SCTP", or "DTLS/SCTP" (for backwards
      compatibility) profiles.

   Note that re-offers by JSEP endpoints MUST use the correct profile
   strings even if the initial offer/answer exchange used an (incorrect)
   older profile string.

5.2.  Constructing an Offer

   When createOffer is called, a new SDP description must be created
   that includes the functionality specified in
   [I-D.ietf-rtcweb-rtp-usage].  The exact details of this process are
   explained below.

5.2.1.  Initial Offers

   When createOffer is called for the first time, the result is known as
   the initial offer.

   The first step in generating an initial offer is to generate session-
   level attributes, as specified in [RFC4566], Section 5.
   Specifically:

   o  The first SDP line MUST be "v=0", as specified in [RFC4566],
      Section 5.1

   o  The second SDP line MUST be an "o=" line, as specified in
      [RFC4566], Section 5.2.  The value of the <username> field SHOULD
      be "-".  The value of the <sess-id> field SHOULD be a
      cryptographically random number.  To ensure uniqueness, this
      number SHOULD be at least 64 bits long.  The value of the <sess-
      version> field SHOULD be zero.  The value of the <nettype>
      <addrtype> <unicast-address> tuple SHOULD be set to a non-
      meaningful address, such as IN IP4 0.0.0.0, to prevent leaking the
      local address in this field.  As mentioned in [RFC4566], the


      entire o= line needs to be unique, but selecting a random number
      for <sess-id> is sufficient to accomplish this.

   o  The third SDP line MUST be a "s=" line, as specified in [RFC4566],
      Section 5.3; to match the "o=" line, a single dash SHOULD be used
      as the session name, e.g. "s=-".  Note that this differs from the
      advice in [RFC4566] which proposes a single space, but as both
      "o=" and "s=" are meaningless, having the same meaningless value
      seems clearer.

   o  Session Information ("i="), URI ("u="), Email Address ("e="),
      Phone Number ("p="), Bandwidth ("b="), Repeat Times ("r="), and
      Time Zones ("z=") lines are not useful in this context and SHOULD
      NOT be included.

   o  Encryption Keys ("k=") lines do not provide sufficient security
      and MUST NOT be included.

   o  A "t=" line MUST be added, as specified in [RFC4566], Section 5.9;
      both <start-time> and <stop-time> SHOULD be set to zero, e.g. "t=0
      0".

   o  An "a=ice-options" line with the "trickle" option MUST be added,
      as specified in [I-D.ietf-ice-trickle], Section 4.

   The next step is to generate m= sections, as specified in [RFC4566]
   Section 5.14.  An m= section is generated for each RtpTransceiver
   that has been added to the PeerConnection via the addTrack,
   addTransceiver, and setRemoteDescription methods.  [[OPEN ISSUE: move
   discussion of setRemoteDescription to the subsequent-offer section.]]
   This is done in the order that their associated RtpTransceivers were
   added to the PeerConnection and excludes RtpTranscievers that are
   stopped and not associated with an m= section (either due to an m=
   section being recycled or an RtpTransceiver having been stopped
   before being associated with an m= section) .

   Each m= section, provided it is not marked as bundle-only, MUST
   generate a unique set of ICE credentials and gather its own unique
   set of ICE candidates.  Bundle-only m= sections MUST NOT contain any
   ICE credentials and MUST NOT gather any candidates.

   For DTLS, all m= sections MUST use the certificate for the identity
   that has been specified for the PeerConnection; as a result, they
   MUST all have the same [RFC4572] fingerprint value, or this value
   MUST be a session-level attribute.




   Each m= section should be generated as specified in [RFC4566],
   Section 5.14.  For the m= line itself, the following rules MUST be
   followed:

   o  The port value is set to the port of the default ICE candidate for
      this m= section, but given that no candidates have yet been
      gathered, the "dummy" port value of 9 (Discard) MUST be used, as
      indicated in [I-D.ietf-ice-trickle], Section 5.1.

   o  To properly indicate use of DTLS, the <proto> field MUST be set to
      "UDP/TLS/RTP/SAVPF", as specified in [RFC5764], Section 8, if the
      default candidate uses UDP transport, or "TCP/DTLS/RTP/SAVPF", as
      specified in [I-D.nandakumar-mmusic-proto-iana-registration] if
      the default candidate uses TCP transport.

   The m= line MUST be followed immediately by a "c=" line, as specified
   in [RFC4566], Section 5.7.  Again, as no candidates have yet been
   gathered, the "c=" line must contain the "dummy" value "IN IP4
   0.0.0.0", as defined in [I-D.ietf-ice-trickle], Section 5.1.

   Each m= section MUST include the following attribute lines:

   o  An "a=mid" line, as specified in [RFC5888], Section 4.  When
      generating mid values, it is RECOMMENDED that the values be 3
      bytes or less, to allow them to efficiently fit into the RTP
      header extension defined in
      [I-D.ietf-mmusic-sdp-bundle-negotiation], Section 11.

   o  An "a=rtcp" line, as specified in [RFC3605], Section 2.1,
      containing the dummy value "9 IN IP4 0.0.0.0", because no
      candidates have yet been gathered.

   o  A direction attribute for the associated RtpTransceiver as
      described by Section 5.2.4.

   o  For each supported codec, "a=rtpmap" and "a=fmtp" lines, as
      specified in [RFC4566], Section 6.  The audio and video codecs
      that MUST be supported are specified in
      [I-D.ietf-rtcweb-audio](see Section 3) and
      [I-D.ietf-rtcweb-video](see Section 5).

   o  If this m= section is for media with configurable frame sizes,
      e.g. audio, an "a=maxptime" line, indicating the smallest of the
      maximum supported frame sizes out of all codecs included above, as
      specified in [RFC4566], Section 6.




   o  If this m= section is for video media, and there are known
      limitations on the size of images which can be decoded, an
      "a=imageattr" line, as specified in Section 3.6.

   o  For each primary codec where RTP retransmission should be used, a
      corresponding "a=rtpmap" line indicating "rtx" with the clock rate
      of the primary codec and an "a=fmtp" line that references the
      payload type of the primary codec, as specified in [RFC4588],
      Section 8.1.

   o  For each supported FEC mechanism, "a=rtpmap" and "a=fmtp" lines,
      as specified in [RFC4566], Section 6.  The FEC mechanisms that
      MUST be supported are specified in [I-D.ietf-rtcweb-fec],
      Section 6, and specific usage for each media type is outlined in
      Sections 4 and 5.

   o  "a=ice-ufrag" and "a=ice-pwd" lines, as specified in [RFC5245],
      Section 15.4.

   o  An "a=fingerprint" line for each of the endpoint's certificates,
      as specified in [RFC4572], Section 5; the digest algorithm used
      for the fingerprint MUST match that used in the certificate
      signature.

   o  An "a=setup" line, as specified in [RFC4145], Section 4, and
      clarified for use in DTLS-SRTP scenarios in [RFC5763], Section 5.
      The role value in the offer MUST be "actpass".

   o  An "a=rtcp-mux" line, as specified in [RFC5761], Section 5.1.1.

   o  An "a=rtcp-rsize" line, as specified in [RFC5506], Section 5.

   o  For each supported RTP header extension, an "a=extmap" line, as
      specified in [RFC5285], Section 5.  The list of header extensions
      that SHOULD/MUST be supported is specified in
      [I-D.ietf-rtcweb-rtp-usage], Section 5.2.  Any header extensions
      that require encryption MUST be specified as indicated in
      [RFC6904], Section 4.

   o  For each supported RTCP feedback mechanism, an "a=rtcp-fb"
      mechanism, as specified in [RFC4585], Section 4.2.  The list of
      RTCP feedback mechanisms that SHOULD/MUST be supported is
      specified in [I-D.ietf-rtcweb-rtp-usage], Section 5.1.

   o  An "a=ssrc" line, as specified in [RFC5576], Section 4.1,
      indicating the SSRC to be used for sending media, along with the
      mandatory "cname" source attribute, as specified in Section 6.1,


      indicating the CNAME for the source.  The CNAME MUST be generated
      in accordance with Section 4.9 of [I-D.ietf-rtcweb-rtp-usage].

   o  If RTX is supported for this media type, another "a=ssrc" line
      with the RTX SSRC, and an "a=ssrc-group" line, as specified in
      [RFC5576], section 4.2, with semantics set to "FID" and including
      the primary and RTX SSRCs.

   o  If FEC is supported for this media type, another "a=ssrc" line
      with the FEC SSRC, and an "a=ssrc-group" line with semantics set
      to "FEC-FR" and including the primary and FEC SSRCs, as specified
      in [RFC5956], section 4.3.  For simplicity, if both RTX and FEC
      are supported, the FEC SSRC MUST be the same as the RTX SSRC.

   o  If the bundle policy for this PeerConnection is set to "max-
      bundle", and this is not the first m= section, or the bundle
      policy is set to "balanced", and this is not the first m= section
      for this media type, an "a=bundle-only" line.

   o  If the RtpSender of the RtpTransceiver associated with this
      m=section is active:

      *  An "a=msid" line, as specified in [I-D.ietf-mmusic-msid],
         Section 2.

      *  An "a=ssrc" line, as specified in [RFC5576], Section 4.1,
         indicating the SSRC to be used for sending media, along with
         the mandatory "cname" source attribute, as specified in
         Section 6.1, indicating the CNAME for the source.  The CNAME
         MUST be generated in accordance with Section 4.9 of
         [I-D.ietf-rtcweb-rtp-usage].

      *  If RTX is supported for this media type, another "a=ssrc" line
         with the RTX SSRC, and an "a=ssrc-group" line, as specified in
         [RFC5576], section 4.2, with semantics set to "FID" and
         including the primary and RTX SSRCs.

      *  If FEC is supported for this media type, another "a=ssrc" line
         with the FEC SSRC, and an "a=ssrc-group" line with semantics
         set to "FEC-FR" and including the primary and FEC SSRCs, as
         specified in [RFC5956], section 4.3.  For simplicity, if both
         RTX and FEC are supported, the FEC SSRC MUST be the same as the
         RTX SSRC.

   o  If the RtpTransceiver's RtpSender is active, and the application
      has specified RID values or has specified more than one encoding
      in the RtpSenders's parameters, an "a=rid" line for each encoding


      [I-D.ietf-mmusic-rid], and its direction MUST be "send".  If the
      application has chosen a RID value, it MUST be used as the rid-
      identifier; otherwise a RID value MUST be generated by the
      implementation.  When generating RID values, it is RECOMMENDED
      that the values be 3 bytes or less, to allow them to efficiently
      fit into the RTP header extension defined in
      [I-D.ietf-avtext-rid], Section 11.  If no encodings have been
      specified, or only one encoding is specified but without a RID
      value, then no "a=rid" lines are generated.

   o  If the RtpTransceiver's RtpSender is active and more than one
      "a=rid" line has been generated, an "a=simulcast" line, with
      direction "send", as defined in [I-D.ietf-mmusic-sdp-simulcast],
      Section 6.2.  The list of RIDs MUST include all of the RID
      identifiers used in the "a=rid" lines for this m= section.

   Lastly, if a data channel has been created, a m= section MUST be
   generated for data.  The <media> field MUST be set to "application"
   and the <proto> field MUST be set to "UDP/DTLS/SCTP" if the default
   candidate uses UDP transport, or "TCP/DTLS/SCTP" if the default
   candidate uses TCP transport [I-D.ietf-mmusic-sctp-sdp].  The "fmt"
   value MUST be set to "webrtc-datachannel" as specified in
   [I-D.ietf-mmusic-sctp-sdp], Section 4.1.

   Within the data m= section, the "a=mid", "a=ice-ufrag", "a=ice-pwd",
   "a=fingerprint", and "a=setup" lines MUST be included as mentioned
   above, along with an "a=fmtp:webrtc-datachannel" line and an "a=sctp-
   port" line referencing the SCTP port number as defined in
   [I-D.ietf-mmusic-sctp-sdp], Section 4.1.

   Once all m= sections have been generated, a session-level "a=group"
   attribute MUST be added as specified in [RFC5888].  This attribute
   MUST have semantics "bundle", and MUST include the mid identifiers of
   each m= section.  The effect of this is that the browser offers all
   m= sections as one bundle group.  However, whether the m= sections
   are bundle-only or not depends on the bundle policy.

   The next step is to generate session-level lip sync groups as defined
   in [RFC5888], Section 7.  For each MediaStream referenced by more
   than one RtpTransceiver (by passing those MediaStreams as arguments
   to the addTrack and addTransceiver methods), a group of type "LS"
   MUST be added that contains the mid values for each RtpTransceiver.

   Attributes which SDP permits to either be at the session level or the
   media level SHOULD generally be at the media level even if they are
   identical.  This promotes readability, especially if one of a set of
   initially identical attributes is subsequently changed.


   Attributes other than the ones specified above MAY be included,
   except for the following attributes which are specifically
   incompatible with the requirements of [I-D.ietf-rtcweb-rtp-usage],
   and MUST NOT be included:

   o  "a=crypto"

   o  "a=key-mgmt"

   o  "a=ice-lite"

   Note that when bundle is used, any additional attributes that are
   added MUST follow the advice in [I-D.ietf-mmusic-sdp-mux-attributes]
   on how those attributes interact with bundle.

   Note that these requirements are in some cases stricter than those of
   SDP.  Implementations MUST be prepared to accept compliant SDP even
   if it would not conform to the requirements for generating SDP in
   this specification.

5.2.2.  Subsequent Offers

   When createOffer is called a second (or later) time, or is called
   after a local description has already been installed, the processing
   is somewhat different than for an initial offer.

   If the initial offer was not applied using setLocalDescription,
   meaning the PeerConnection is still in the "stable" state, the steps
   for generating an initial offer should be followed, subject to the
   following restriction:

   o  The fields of the "o=" line MUST stay the same except for the
      <session-version> field, which MUST increment if the session
      description changes in any way, including the addition of ICE
      candidates.

   If the initial offer was applied using setLocalDescription, but an
   answer from the remote side has not yet been applied, meaning the
   PeerConnection is still in the "local-offer" state, an offer is
   generated by following the steps in the "stable" state above, along
   with these exceptions:

   o  The "s=" and "t=" lines MUST stay the same.

   o  If any RtpTransceiver has been added, and there exists an m=
      section with a zero port in the current local description or the
      current remote description, that m= section MUST be recycled by


      section were being added to the session description, placed at the
      same index as the m= section with a zero port.

   o  If an RtpTransceiver is stopped and is not associated with an m=
      section, an m= section MUST NOT be generated for it.  This
      prevents adding back RtpTransceivers whose m= sections were
      recycled and used for a new RtpTransceiver in a previous offer/
      answer exchange, as described above.

   o  If an RtpTransceiver has been stopped and is associated with an m=
      section, and the m= section is not being recycled as described
      above, an m= section MUST be generated for it with the port set to
      zero and the "a=msid", "a=ssrc", and "a=ssrc-group" lines removed.

   o  For RtpTransceivers that are not stopped, the "a=msid", "a=ssrc",
      and "a=ssrc-group" lines MUST stay the same if they are present in
      the current description.

   o  Each "m=" and c=" line MUST be filled in with the port, protocol,
      and address of the default candidate for the m= section, as
      described in [RFC5245], Section 4.3.  If ICE checking has already
      completed for one or more candidate pairs and a candidate pair is
      in active use, then that pair MUST be used, even if ICE has not
      yet completed.  Note that this differs from the guidance in
      [RFC5245], Section 9.1.2.2, which only refers to offers created
      when ICE has completed.  Each "a=rtcp" attribute line MUST also be
      filled in with the port and address of the appropriate default
      candidate, either the default RTP or RTCP candidate, depending on
      whether RTCP multiplexing is currently active or not.  Note that
      if RTCP multiplexing is being offered, but not yet active, the
      default RTCP candidate MUST be used, as indicated in [RFC5761],
      section 5.1.3.  In each case, if no candidates of the desired type
      have yet been gathered, dummy values MUST be used, as described
      above.

   o  Each "a=mid" line MUST stay the same.

   o  Each "a=ice-ufrag" and "a=ice-pwd" line MUST stay the same, unless
      the ICE configuration has changed (either changes to the supported
      STUN/TURN servers, or the ICE candidate policy), or the
      "IceRestart" option ( Section 5.2.3.1 was specified.  If the m=
      section is bundled into another m= section, it still MUST NOT
      contain any ICE credentials.

   o  If the m= section is not bundled into another m= section, for each
      candidate that has been gathered during the most recent gathering
      phase (see Section 3.5.1), an "a=candidate" line MUST be added, as


      gathering for the section has completed, an "a=end-of-candidates"
      attribute MUST be added, as described in [I-D.ietf-ice-trickle],
      Section 9.3.  If the m= section is bundled into another m=
      section, both "a=candidate" and "a=end-of-candidates" MUST be
      omitted.

   o  For RtpTransceivers that are still present, the "a=msid",
      "a=ssrc", and "a=ssrc-group" lines MUST stay the same.

   o  For RtpTransceivers that are still present, the "a=rid" lines MUST
      stay the same.

   o  For RtpTransceivers that are still present, any "a=simulcast" line
      MUST stay the same.

   o  If any RtpTransceiver has been stopped, the port MUST be set to
      zero and the "a=msid", "a=ssrc", and "a=ssrc-group" lines MUST be
      removed.

   o  If any RtpTransceiver has been added, and there exists a m=
      section with a zero port in the current local description or the
      current remote description, that m= section MUST be recycled by
      generating a m= section for the added RtpTransceiver as if the m=
      section were being added to session description, except that
      instead of adding it, the generated m= section replaces the m=
      section with a zero port.

   If the initial offer was applied using setLocalDescription, and an
   answer from the remote side has been applied using
   setRemoteDescription, meaning the PeerConnection is in the "remote-
   pranswer" or "stable" states, an offer is generated based on the
   negotiated session descriptions by following the steps mentioned for
   the "local-offer" state above.

   In addition, for each non-recycled, non-rejected m= section in the
   new offer, the following adjustments are made based on the contents
   of the corresponding m= section in the current remote description:

   o  The m= line and corresponding "a=rtpmap" and "a=fmtp" lines MUST
      only include codecs present in the most recent answer.

   o  The RTP header extensions MUST only include those that are present
      in the most recent answer.

   o  The RTCP feedback extensions MUST only include those that are
      present in the most recent answer.



   o  The "a=rtcp-mux" line MUST only be added if present in the most
      recent answer.

   o  The "a=rtcp-rsize" line MUST only be added if present in the most
      recent answer.

   The "a=group:BUNDLE" attribute MUST include the mid identifiers
   specified in the bundle group in the most recent answer, minus any m=
   sections that have been marked as rejected, plus any newly added or
   re-enabled m= sections.  In other words, the bundle attribute must
   contain all m= sections that were previously bundled, as long as they
   are still alive, as well as any new m= sections.

   The "LS" groups are generated in the same way as with initial offers.

5.2.3.  Options Handling

   The createOffer method takes as a parameter an RTCOfferOptions
   object.  Special processing is performed when generating a SDP
   description if the following options are present.

5.2.3.1.  IceRestart

   If the "IceRestart" option is specified, with a value of "true", the
   offer MUST indicate an ICE restart by generating new ICE ufrag and
   pwd attributes, as specified in [RFC5245], Section 9.1.1.1.  If this
   option is specified on an initial offer, it has no effect (since a
   new ICE ufrag and pwd are already generated).  Similarly, if the ICE
   configuration has changed, this option has no effect, since new ufrag
   and pwd attributes will be generated automatically.  This option is
   primarily useful for reestablishing connectivity in cases where
   failures are detected by the application.

5.2.3.2.  VoiceActivityDetection

   If the "VoiceActivityDetection" option is specified, with a value of
   "true", the offer MUST indicate support for silence suppression in
   the audio it receives by including comfort noise ("CN") codecs for
   each offered audio codec, as specified in [RFC3389], Section 5.1,
   except for codecs that have their own internal silence suppression
   support.  For codecs that have their own internal silence suppression
   support, the appropriate fmtp parameters for that codec MUST be
   specified to indicate that silence suppression for received audio is
   desired.  For example, when using the Opus codec, the "usedtx=1"
   parameter would be specified in the offer.  This option allows the
   endpoint to significantly reduce the amount of audio bandwidth it
   receives, at the cost of some fidelity, depending on the quality of


   If the "VoiceActivityDetection" option is specified, with a value of
   "false", the browser MUST NOT emit "CN" codecs.  For codecs that have
   their own internal silence suppression support, the appropriate fmtp
   parameters for that codec MUST be specified to indicate that silence
   suppression for received audio is not desired.  For example, when
   using the Opus codec, the "usedtx=0" parameter would be specified in
   the offer.

   Note that setting the "VoiceActivityDetection" parameter when
   generating an offer is a request to receive audio with silence
   suppression.  It has no impact on whether the local endpoint does
   silence suppression for the audio it sends.

   The "VoiceActivityDetection" option does not have any impact on the
   setting of the "vad" value in the signaling of the client to mixer
   audio level header extension described in [RFC6464], Section 4.

5.2.4.  Direction Attribute in Offers

   [RFC3264] direction attributes (defined in Section 6.1) in offers are
   chosen according to the states of the RtpSender and RtpReceiver of a
   given RtpTransceiver, as follows:

               +-----------+-------------+-----------------+
               | RtpSender | RtpReceiver | offer direction |
               +-----------+-------------+-----------------+
               |   active  |    active   |     sendrecv    |
               |   active  |   inactive  |     sendonly    |
               |  inactive |    active   |     recvonly    |
               |  inactive |   inactive  |     inactive    |
               +-----------+-------------+-----------------+

5.3.  Generating an Answer

   When createAnswer is called, a new SDP description must be created
   that is compatible with the supplied remote description as well as
   the requirements specified in [I-D.ietf-rtcweb-rtp-usage].  The exact
   details of this process are explained below.

5.3.1.  Initial Answers

   When createAnswer is called for the first time after a remote
   description has been provided, the result is known as the initial
   answer.  If no remote description has been installed, an answer
   cannot be generated, and an error MUST be returned.

   Note that the remote description SDP may not have been created by a


   Section 5.2.  For many cases, this is not a problem.  However, if any
   mandatory SDP attributes are missing, or functionality listed as
   mandatory-to-use above is not present, this MUST be treated as an
   error, and MUST cause the affected m= sections to be marked as
   rejected.

   The first step in generating an initial answer is to generate
   session-level attributes.  The process here is identical to that
   indicated in the Initial Offers section above, except that the
   "a=ice-options" line, with the "trickle" option as specified in
   [I-D.ietf-ice-trickle], Section 4, is only included if such an option
   was present in the offer.

   The next step is to generate session-level lip sync groups as defined
   in [RFC5888], Section 7.  For each group of type "LS" present in the
   offer, determine which of the local RtpTransceivers identified by
   that group's mid values reference a common local MediaStream (as
   specified in the addTrack and addTransceiver methods).  If at least
   two such RtpTransceivers exist, a group of type "LS" with the mid
   values of these RtpTransceivers MUST be added.  Otherwise, this
   indicates a difference of opinion between the offerer and answerer
   regarding lip sync status, and as such, the offered group MUST be
   ignored and no corresponding "LS" group generated.

   The next step is to generate m= sections for each m= section that is
   present in the remote offer, as specified in [RFC3264], Section 6.
   For the purposes of this discussion, any session-level attributes in
   the offer that are also valid as media-level attributes SHALL be
   considered to be present in each m= section.

   The next step is to go through each offered m= section.  Each offered
   m= section will have an associated RtpTransceiver, as described in
   Section 5.8.  If there are more RtpTransceivers than there are m=
   sections, the unmatched RtpTransceivers will need to be associated in
   a subsequent offer.

   For each offered m= section, if any of the following conditions are
   true, the corresponding m= section in the answer MUST be marked as
   rejected by setting the port in the m= line to zero, as indicated in
   [RFC3264], Section 6., and further processing for this m= section can
   be skipped:

   o  The associated RtpTransceiver has been stopped.

   o  No supported codec is present in the offer.

   o  The bundle policy is "max-bundle", the m= section is not in a


   o  The bundle policy is "balanced", the m= section is not in a bundle
      group, and this is not the first m= section for this media type.

   o  The RTP/RTCP multiplexing policy is "require" and the m= section
      doesn't contain an "a=rtcp-mux" attribute.

   Otherwise, each m= section in the answer should then be generated as
   specified in [RFC3264], Section 6.1.  For the m= line itself, the
   following rules must be followed:

   o  The port value would normally be set to the port of the default
      ICE candidate for this m= section, but given that no candidates
      have yet been gathered, the "dummy" port value of 9 (Discard) MUST
      be used, as indicated in [I-D.ietf-ice-trickle], Section 5.1.

   o  The <proto> field MUST be set to exactly match the <proto> field
      for the corresponding m= line in the offer.

   The m= line MUST be followed immediately by a "c=" line, as specified
   in [RFC4566], Section 5.7.  Again, as no candidates have yet been
   gathered, the "c=" line must contain the "dummy" value "IN IP4
   0.0.0.0", as defined in [I-D.ietf-ice-trickle], Section 5.1.

   If the offer supports bundle, all m= sections to be bundled must use
   the same ICE credentials and candidates; all m= sections not being
   bundled must use unique ICE credentials and candidates.  Each m=
   section MUST include the following:

   o  If and only if present in the offer, an "a=mid" line, as specified
      in [RFC5888], Section 9.1.  The "mid" value MUST match that
      specified in the offer.

   o  An "a=rtcp" line, as specified in [RFC3605], Section 2.1,
      containing the dummy value "9 IN IP4 0.0.0.0", because no
      candidates have yet been gathered.

   o  A direction attribute for the associated RtpTransceiver described
      by Section 5.3.4.

   o  For each supported codec that is present in the offer, "a=rtpmap"
      and "a=fmtp" lines, as specified in [RFC4566], Section 6, and
      [RFC3264], Section 6.1.  The audio and video codecs that MUST be
      supported are specified in [I-D.ietf-rtcweb-audio](see Section 3)
      and [I-D.ietf-rtcweb-video](see Section 5).

   o  If this m= section is for media with configurable frame sizes,
      e.g. audio, an "a=maxptime" line, indicating the smallest of the


      maximum supported frame sizes out of all codecs included above, as
      specified in [RFC4566], Section 6.

   o  If this m= section is for video media, and there are known
      limitations on the size of images which can be decoded, an
      "a=imageattr" line, as specified in Section 3.6.

   o  If "rtx" is present in the offer, for each primary codec where RTP
      retransmission should be used, a corresponding "a=rtpmap" line
      indicating "rtx" with the clock rate of the primary codec and an
      "a=fmtp" line that references the payload type of the primary
      codec, as specified in [RFC4588], Section 8.1.

   o  For each supported FEC mechanism, "a=rtpmap" and "a=fmtp" lines,
      as specified in [RFC4566], Section 6.  The FEC mechanisms that
      MUST be supported are specified in [I-D.ietf-rtcweb-fec],
      Section 6, and specific usage for each media type is outlined in
      Sections 4 and 5.

   o  "a=ice-ufrag" and "a=ice-pwd" lines, as specified in [RFC5245],
      Section 15.4.

   o  An "a=fingerprint" line for each of the endpoint's certificates,
      as specified in [RFC4572], Section 5; the digest algorithm used
      for the fingerprint MUST match that used in the certificate
      signature.

   o  An "a=setup" line, as specified in [RFC4145], Section 4, and
      clarified for use in DTLS-SRTP scenarios in [RFC5763], Section 5.
      The role value in the answer MUST be "active" or "passive"; the
      "active" role is RECOMMENDED.

   o  If present in the offer, an "a=rtcp-mux" line, as specified in
      [RFC5761], Section 5.1.1.  If the "require" RTCP multiplexing
      policy is set and no "a=rtcp-mux" line is present in the offer,
      then the m=line MUST be marked as rejected by setting the port in
      the m= line to zero, as indicated in [RFC3264], Section 6.

   o  If present in the offer, an "a=rtcp-rsize" line, as specified in
      [RFC5506], Section 5.

   o  For each supported RTP header extension that is present in the
      offer, an "a=extmap" line, as specified in [RFC5285], Section 5.
      The list of header extensions that SHOULD/MUST be supported is
      specified in [I-D.ietf-rtcweb-rtp-usage], Section 5.2.  Any header
      extensions that require encryption MUST be specified as indicated
      in [RFC6904], Section 4.


   o  For each supported RTCP feedback mechanism that is present in the
      offer, an "a=rtcp-fb" mechanism, as specified in [RFC4585],
      Section 4.2.  The list of RTCP feedback mechanisms that SHOULD/
      MUST be supported is specified in [I-D.ietf-rtcweb-rtp-usage],
      Section 5.1.

   o  If the RtpSender of the RtpTransceiver associated with this
      m=section is active:

      *  An "a=msid" line, as specified in [I-D.ietf-mmusic-msid],
         Section 2.

      *  An "a=ssrc" line, as specified in [RFC5576], Section 4.1,
         indicating the SSRC to be used for sending media, along with
         the mandatory "cname" source attribute, as specified in
         Section 6.1, indicating the CNAME for the source.  The CNAME
         MUST be generated in accordance with Section 4.9 of
         [I-D.ietf-rtcweb-rtp-usage].

      *  If RTX has been negotiated for this m= section, another
         "a=ssrc" line with the RTX SSRC, and an "a=ssrc-group" line, as
         specified in [RFC5576], section 4.2, with semantics set to
         "FID" and including the primary and RTX SSRCs.

      *  If FEC has been negotiated for this m= section, another
         "a=ssrc" line with the FEC SSRC, and an "a=ssrc-group" line
         with semantics set to "FEC-FR" and including the primary and
         FEC SSRCs, as specified in [RFC5956], section 4.3.  For
         simplicity, if both RTX and FEC are supported, the FEC SSRC
         MUST be the same as the RTX SSRC.

   If a data channel m= section has been offered, a m= section MUST also
   be generated for data.  The <media> field MUST be set to
   "application" and the <proto> and "fmt" fields MUST be set to exactly
   match the fields in the offer.

   Within the data m= section, the "a=mid", "a=ice-ufrag", "a=ice-pwd",
   "a=candidate", "a=fingerprint", and "a=setup" lines MUST be included
   as mentioned above, along with an "a=fmtp:webrtc-datachannel" line
   and an "a=sctp-port" line referencing the SCTP port number as defined
   in [I-D.ietf-mmusic-sctp-sdp], Section 4.1.

   If "a=group" attributes with semantics of "BUNDLE" are offered,
   corresponding session-level "a=group" attributes MUST be added as
   specified in [RFC5888].  These attributes MUST have semantics
   "BUNDLE", and MUST include the all mid identifiers from the offered
   bundle groups that have not been rejected.  Note that regardless of


   the presence of "a=bundle-only" in the offer, no m= sections in the
   answer should have an "a=bundle-only" line.

   Attributes that are common between all m= sections MAY be moved to
   session-level, if explicitly defined to be valid at session-level.

   The attributes prohibited in the creation of offers are also
   prohibited in the creation of answers.

5.3.2.  Subsequent Answers

   When createAnswer is called a second (or later) time, or is called
   after a local description has already been installed, the processing
   is somewhat different than for an initial answer.

   If the initial answer was not applied using setLocalDescription,
   meaning the PeerConnection is still in the "have-remote-offer" state,
   the steps for generating an initial answer should be followed,
   subject to the following restriction:

   o  The fields of the "o=" line MUST stay the same except for the
      <session-version> field, which MUST increment if the session
      description changes in any way from the previously generated
      answer.

   If any session description was previously supplied to
   setLocalDescription, an answer is generated by following the steps in
   the "have-remote-offer" state above, along with these exceptions:

   o  The "s=" and "t=" lines MUST stay the same.

   o  Each "m=" and c=" line MUST be filled in with the port and address
      of the default candidate for the m= section, as described in
      [RFC5245], Section 4.3.  Note, however, that the m= line protocol
      need not match the default candidate, because this protocol value
      must instead match what was supplied in the offer, as described
      above.  Each "a=rtcp" attribute line MUST also be filled in with
      the port and address of the appropriate default candidate, either
      the default RTP or RTCP candidate, depending on whether RTCP
      multiplexing is enabled in the answer.  In each case, if no
      candidates of the desired type have yet been gathered, dummy
      values MUST be used, as described in the initial answer section
      above.

   o  Each "a=ice-ufrag" and "a=ice-pwd" line MUST stay the same, unless
      the m= section is restarting, in which case new ICE credentials
      must be created as specified in [RFC5245], Section 9.2.1.1.  If


      the m= section is bundled into another m= section, it still MUST
      NOT contain any ICE credentials.

   o  If the m= section is not bundled into another m= section, for each
      candidate that has been gathered during the most recent gathering
      phase (see Section 3.5.1), an "a=candidate" line MUST be added, as
      defined in [RFC5245], Section 4.3., paragraph 3.  If candidate
      gathering for the section has completed, an "a=end-of-candidates"
      attribute MUST be added, as described in [I-D.ietf-ice-trickle],
      Section 9.3.  If the m= section is bundled into another m=
      section, both "a=candidate" and "a=end-of-candidates" MUST be
      omitted.

   o  For RtpTransceivers that are not stopped, the "a=msid", "a=ssrc",
      and "a=ssrc-group" lines MUST stay the same.

5.3.3.  Options Handling

   The createAnswer method takes as a parameter an RTCAnswerOptions
   object.  The set of parameters for RTCAnswerOptions is different than
   those supported in RTCOfferOptions; the IceRestart option is
   unnecessary, as ICE credentials will automatically be changed for all
   m= lines where the offerer chose to perform ICE restart.

   The following options are supported in RTCAnswerOptions.

5.3.3.1.  VoiceActivityDetection

   Silence suppression in the answer is handled as described in
   Section 5.2.3.2, with one exception: if support for silence
   suppression was not indicated in the offer, the
   VoiceActivityDetection parameter has no effect, and the answer should
   be generated as if VoiceActivityDetection was set to false.  This is
   done on a per-codec basis (e.g., if the offerer somehow offered
   support for CN but set "usedtx=0" for Opus, setting
   VoiceActivityDetection to true would result in an answer with CN
   codecs and "usedtx=0").

5.3.4.  Direction Attribute in Answers

   [RFC3264] direction attributes (defined in Section 6.1) in answers
   are chosen according to the direction attribute in the remote offer
   and the states of the RtpSender and RtpReceiver of the corresponding
   RtpTransceiver, as follows:





     +-----------------+-----------+-------------+------------------+
     | offer direction | RtpSender | RtpReceiver | answer direction |
     +-----------------+-----------+-------------+------------------+
     |     sendrecv    |   active  |    active   |     sendrecv     |
     |     sendrecv    |   active  |   inactive  |     sendonly     |
     |     sendrecv    |  inactive |    active   |     recvonly     |
     |     sendrecv    |  inactive |   inactive  |     inactive     |
     |     sendonly    |     *     |    active   |     recvonly     |
     |     sendonly    |     *     |   inactive  |     inactive     |
     |     recvonly    |   active  |      *      |     sendonly     |
     |     recvonly    |  inactive |      *      |     inactive     |
     |     inactive    |     *     |      *      |     inactive     |
     +-----------------+-----------+-------------+------------------+

5.4.  Processing a Local Description

   When a SessionDescription is supplied to setLocalDescription, the
   following steps MUST be performed:

   o  First, the type of the SessionDescription is checked against the
      current state of the PeerConnection:

      *  If the type is "offer", the PeerConnection state MUST be either
         "stable" or "have-local-offer".

      *  If the type is "pranswer" or "answer", the PeerConnection state
         MUST be either "have-remote-offer" or "have-local-pranswer".

   o  If the type is not correct for the current state, processing MUST
      stop and an error MUST be returned.

   o  Next, the SessionDescription is parsed into a data structure, as
      described in the Section 5.6 section below.  If parsing fails for
      any reason, processing MUST stop and an error MUST be returned.

   o  Finally, the parsed SessionDescription is applied as described in
      the Section 5.7 section below.

5.5.  Processing a Remote Description

   When a SessionDescription is supplied to setRemoteDescription, the
   following steps MUST be performed:

   o  First, the type of the SessionDescription is checked against the
      current state of the PeerConnection:

      *  If the type is "offer", the PeerConnection state MUST be either


      *  If the type is "pranswer" or "answer", the PeerConnection state
         MUST be either "have-local-offer" or "have-remote-pranswer".

   o  If the type is not correct for the current state, processing MUST
      stop and an error MUST be returned.

   o  Next, the SessionDescription is parsed into a data structure, as
      described in the Section 5.6 section below.  If parsing fails for
      any reason, processing MUST stop and an error MUST be returned.

   o  Finally, the parsed SessionDescription is applied as described in
      the Section 5.8 section below.

5.6.  Parsing a Session Description

   When a SessionDescription of any type is supplied to setLocal/
   RemoteDescription, the implementation must parse it and reject it if
   it is invalid.  The exact details of this process are explained
   below.

   The SDP contained in the session description object consists of a
   sequence of text lines, each containing a key-value expression, as
   described in [RFC4566], Section 5.  The SDP is read, line-by-line,
   and converted to a data structure that contains the deserialized
   information.  However, SDP allows many types of lines, not all of
   which are relevant to JSEP applications.  For each line, the
   implementation will first ensure it is syntactically correct
   according its defining ABNF, check that it conforms to [RFC4566] and
   [RFC3264] semantics, and then either parse and store or discard the
   provided value, as described below.  A partial list of ABNF
   definitions for SDP attributes can found in:


















      +-------------------------+----------------------------------+
      | Attribute               | Reference                        |
      +-------------------------+----------------------------------+
      | ptime                   | [RFC4566] Section 9              |
      | maxptime                | [RFC4566] Section 9              |
      | rtpmap                  | [RFC4566] Section 9              |
      | recvonly                | [RFC4566] Section 9              |
      | sendrecv                | [RFC4566] Section 9              |
      | sendonly                | [RFC4566] Section 9              |
      | inactive                | [RFC4566] Section 9              |
      | framerate               | [RFC4566] Section 9              |
      | fmtp                    | [RFC4566] Section 9              |
      | quality                 | [RFC4566] Section 9              |
      | msid                    | [I-D.ietf-mmusic-msid] Section 2 |
      | rtcp                    | [RFC3605] Section 2.1            |
      | setup                   | [RFC4145] Section 3, 4, and 5    |
      | connection              | [RFC4145] Section 3, 4, and 5    |
      | fingerprint             | [RFC4572] Section 5              |
      | rtcp-fb                 | [RFC4585] Section 4.2            |
      | candidate               | [RFC5245] Section 15             |
      | extmap                  | [RFC5285] Section 7              |
      | mid                     | [RFC5888] Section 4 and 5        |
      | group                   | [RFC5888] Section 4 and 5        |
      | imageattr               | [RFC6236] Section 3.1            |
      | extmap (encrypt option) | [RFC6904] Section 4              |
      +-------------------------+----------------------------------+

                       Table 1: SDP ABNF References

   [TODO: ensure that every line is listed below.]

   If the line is not well-formed, or cannot be parsed as described, the
   parser MUST stop with an error and reject the session description.
   This ensures that implementations do not accidentally misinterpret
   ambiguous SDP.

5.6.1.  Session-Level Parsing

   First, the session-level lines are checked and parsed.  These lines
   MUST occur in a specific order, and with a specific syntax, as
   defined in [RFC4566], Section 5.  Note that while the specific line
   types (e.g. "v=", "c=") MUST occur in the defined order, lines of the
   same type (typically "a=") can occur in any order, and their ordering
   is not meaningful.

   For non-attribute (non-"a=") lines, their sequencing, syntax, and
   semantics, are checked, as mentioned above.  The following lines are


   not meaningful in the JSEP context and MAY be discarded once they
   have been checked.

      The "c=" line MUST be checked for syntax but its value is not
      used.  This supersedes the guidance in [RFC5245], Section 6.1, to
      use "ice-mismatch" to indicate mismatches between "c=" and the
      candidate lines; because JSEP always uses ICE, "ice-mismatch" is
      not useful in this context.

      The "i=", "u=", "e=", "p=", "t=", "r=", "z=", and "k=" lines are
      not used by this specification; they MUST be checked for syntax
      but their values are not used.

   The remaining lines are processed as follows:

      The "v=" line MUST have a version of 0, as specified in [RFC4566],
      Section 5.1.

      The "o=" line MUST be parsed as specified in [RFC4566],
      Section 5.2.

      The "b=" line, if present, MUST be parsed as specified in
      [RFC4566], Section 5.8, and the bwtype and bandwidth values
      stored.

   Specific processing MUST be applied for the following session-level
   attribute ("a=") lines:

   o  Any "a=group" lines are parsed as specified in [RFC5888],
      Section 5, and the group's semantics and mids are stored.

   o  If present, a single "a=ice-lite" line is parsed as specified in
      [RFC5245], Section 15.3, and a value indicating the presence of
      ice-lite is stored.

   o  If present, a single "a=ice-ufrag" line is parsed as specified in
      [RFC5245], Section 15.4, and the ufrag value is stored.

   o  If present, a single "a=ice-pwd" line is parsed as specified in
      [RFC5245], Section 15.4, and the password value is stored.

   o  If present, a single "a=ice-options" line is parsed as specified
      in [RFC5245], Section 15.5, and the set of specified options is
      stored.

   o  Any "a=fingerprint" lines are parsed as specified in [RFC4572],
      Section 5, and the set of fingerprint and algorithm values is


   o  If present, a single "a=setup" line is parsed as specified in
      [RFC4145], Section 4, and the setup value is stored.

   o  Any "a=extmap" lines are parsed as specified in [RFC5285],
      Section 5, and their values are stored.

   o  TODO: identity, rtcp-rsize, rtcp-mux, and any other attributes
      valid at session level.

   Once all the session-level lines have been parsed, processing
   continues with the lines in media sections.

5.6.2.  Media Section Parsing

   Like the session-level lines, the media session lines MUST occur in
   the specific order and with the specific syntax defined in [RFC4566],
   Section 5.

   The "m=" line itself MUST be parsed as described in [RFC4566],
   Section 5.14, and the media, port, proto, and fmt values stored.

   Following the "m=" line, specific processing MUST be applied for the
   following non-attribute lines:

   o  As with the "c=" line at the session level, the "c=" line MUST be
      parsed according to [RFC4566], Section 5.7, but its value is not
      used.

   o  The "b=" line, if present, MUST be parsed as specified in
      [RFC4566], Section 5.8, and the bwtype and bandwidth values
      stored.

   Specific processing MUST also be applied for the following attribute
   lines:

   o  If present, a single "a=ice-ufrag" line is parsed as specified in
      [RFC5245], Section 15.4, and the ufrag value is stored.

   o  If present, a single "a=ice-pwd" line is parsed as specified in
      [RFC5245], Section 15.4, and the password value is stored.

   o  If present, a single "a=ice-options" line is parsed as specified
      in [RFC5245], Section 15.5, and the set of specified options is
      stored.

   o  Any "a=fingerprint" lines are parsed as specified in [RFC4572],
      Section 5, and the set of fingerprint and algorithm values is


   o  If present, a single "a=setup" line is parsed as specified in
      [RFC4145], Section 4, and the setup value is stored.

   If the "m=" proto value indicates use of RTP, as described in the
   Section 5.1.3 section above, the following attribute lines MUST be
   processed:

   o  The "m=" fmt value MUST be parsed as specified in [RFC4566],
      Section 5.14, and the individual values stored.

   o  Any "a=rtpmap" or "a=fmtp" lines MUST be parsed as specified in
      [RFC4566], Section 6, and their values stored.

   o  If present, a single "a=ptime" line MUST be parsed as described in
      [RFC4566], Section 6, and its value stored.

   o  If present, a single "a=maxptime" line MUST be parsed as described
      in [RFC4566], Section 6, and its value stored.

   o  If present, a single direction attribute line (e.g. "a=sendrecv")
      MUST be parsed as described in [RFC4566], Section 6, and its value
      stored.

   o  Any "a=ssrc" or "a=ssrc-group" attributes MUST be parsed as
      specified in [RFC5576], Sections 4.1-4.2, and their values stored.

   o  Any "a=extmap" attributes MUST be parsed as specified in
      [RFC5285], Section 5, and their values stored.

   o  Any "a=rtcp-fb" attributes MUST be parsed as specified in
      [RFC4585], Section 4.2., and their values stored.

   o  If present, a single "a=rtcp-mux" attribute MUST be parsed as
      specified in [RFC5761], Section 5.1.1, and its presence or absence
      flagged and stored.

   o  If present, a single "a=rtcp-rsize" attribute MUST be parsed as
      specified in [RFC5506], Section 5, and its presence or absence
      flagged and stored.

   o  If present, a single "a=rtcp" attribute MUST be parsed as
      specified in [RFC3605], Section 2.1, but its value is ignored.

   o  If present, a single "a=msid" attribute MUST be parsed as
      specified in [I-D.ietf-mmusic-msid], Section 3.2, and its value
      stored.



   o  Any "a=candidate" attributes MUST be parsed as specified in
      [RFC5245], Section 4.3, and their values stored.

   o  Any "a=remote-candidates" attributes MUST be parsed as specified
      in [RFC5245], Section 4.3, but their values are ignored.

   o  If present, a single "a=end-of-candidates" attribute MUST be
      parsed as specified in [I-D.ietf-ice-trickle], Section 8.2, and
      its presence or absence flagged and stored.

   o  Any "a=imageattr" attributes MUST be parsed as specified in
      [RFC6236], Section 3, and their values stored.

   o  Any "a=rid" lines MUST be parsed as specified in
      [I-D.ietf-mmusic-rid], Section 10, and their values stored.

   o  If present, a single "a=simulcast" line MUST be parsed as
      specified in [I-D.ietf-mmusic-sdp-simulcast], and its values
      stored.

   Otherwise, if the "m=" proto value indicates use of SCTP, the
   following attribute lines MUST be processed:

   o  The "m=" fmt value MUST be parsed as specified in
      [I-D.ietf-mmusic-sctp-sdp], Section 4.3, and the application
      protocol value stored.

   o  An "a=sctp-port" attribute MUST be present, and it MUST be parsed
      as specified in [I-D.ietf-mmusic-sctp-sdp], Section 5.2, and the
      value stored.

   o  If present, a single "a=max-message-size" attribute MUST be parsed
      as specified in [I-D.ietf-mmusic-sctp-sdp], Section 6, and the
      value stored.  Otherwise, use the specified default.

5.6.3.  Semantics Verification

   Assuming parsing completes successfully, the parsed description is
   then evaluated to ensure internal consistency as well as proper
   support for mandatory features.  Specifically, the following checks
   are performed:

   o  For each m= section, valid values for each of the mandatory-to-use
      features enumerated in Section 5.1.2 MUST be present.  These
      values MAY either be present at the media level, or inherited from
      the session level.



      *  ICE ufrag and password values, which MUST comply with the size
         limits specified in [RFC5245], Section 15.4.

      *  DTLS setup value, which MUST be set according to the rules
         specified in [RFC5763], Section 5, and MUST be consistent with
         the selected role of the current DTLS connection, if one
         exists.[TODO: may need revision, i.e., use of actpass

      *  DTLS fingerprint values, where at least one fingerprint MUST be
         present.

   o  All RID values referenced in an "a=simulcast" line MUST exist as
      "a=rid" lines.

   o  Each m= section is also checked to ensure prohibited features are
      not used.  If this is a local description, the "ice-lite"
      attribute MUST NOT be specified.

   If this session description is of type "pranswer" or "answer", the
   following additional checks are applied:

   o  The session description must follow the rules defined in
      [RFC3264], Section 6, including the requirement that the number of
      m= sections MUST exactly match the number of m= sections in the
      associated offer.

   o  For each m= section, the media type and protocol values MUST
      exactly match the media type and protocol values in the
      corresponding m= section in the associated offer.

5.7.  Applying a Local Description

   The following steps are performed at the media engine level to apply
   a local description.

   First, the parsed parameters are checked to ensure that any
   modifications performed fall within those explicitly permitted by
   Section 6; otherwise, processing MUST stop and an error MUST be
   returned.

   Next, media sections are processed.  For each media section, the
   following steps MUST be performed; if any parameters are out of
   bounds, or cannot be applied, processing MUST stop and an error MUST
   be returned.

   o  If this media section is new, begin gathering candidates for it,
      as defined in [RFC5245], Section 4.1.1, unless it has been marked


   o  Or, if the ICE ufrag and password values have changed, trigger the
      ICE Agent to start an ICE restart and begin gathering new
      candidates for the media section, as defined in [RFC5245],
      Section 9.1.1.1, unless it has been marked as bundle-only.

   o  If the media section proto value indicates use of RTP:

      *  If there is no RtpTransceiver associated with this m= section
         (which should only happen when applying an offer), find one and
         associate it with this m= section according to the following
         steps:

         +  Find the RtpTransceiver that corresponds to the m= section
            with the same MID in the created offer.

         +  Set the value of the RtpTransceiver's mid attribute to the
            MID of the m= section.

      *  If RTCP mux is indicated, prepare to demux RTP and RTCP from
         the RTP ICE component, as specified in [RFC5761],
         Section 5.1.1.  If RTCP mux is not indicated, but was indicated
         in a previous description, this MUST result in an error.

      *  For each specified RTP header extension, establish a mapping
         between the extension ID and URI, as described in section 6 of
         [RFC5285].  If any indicated RTP header extension is unknown,
         this MUST result in an error.

      *  If the MID header extension is supported, prepare to demux RTP
         data intended for this media section based on the MID header
         extension, as described in [I-D.ietf-mmusic-msid], Section 3.2.

      *  For each specified payload type, establish a mapping between
         the payload type ID and the actual media format, as described
         in [RFC3264].  If any indicated payload type is unknown, this
         MUST result in an error.

      *  For each specified "rtx" media format, establish a mapping
         between the RTX payload type and its associated primary payload
         type, as described in [RFC4588], Sections 8.6 and 8.7.  If any
         referenced primary payload types are not present, this MUST
         result in an error.

      *  If the directional attribute is of type "sendrecv" or
         "recvonly", enable receipt and decoding of media.

   Finally, if this description is of type "pranswer" or "answer",


5.8.  Applying a Remote Description

   If the answer contains any "a=ice-options" attributes where "trickle"
   is listed as an attribute, update the PeerConnection canTrickle
   property to be true.  Otherwise, set this property to false.

   The following steps are performed at the media engine level to apply
   a remote description.

   The following steps MUST be performed for attributes at the session
   level; if any parameters are out of bounds, or cannot be applied,
   processing MUST stop and an error MUST be returned.

   o  For any specified "CT" bandwidth value, set this as the limit for
      the maximum total bitrate for all m= sections, as specified in
      Section 5.8 of [RFC4566].  The implementation can decide how to
      allocate the available bandwidth between m= sections to
      simultaneously meet any limits on individual m= sections, as well
      as this overall session limit.

   o  For any specified "RR" or "RS" bandwidth values, handle as
      specified in [RFC3556], Section 2.

   o  Any "AS" bandwidth value MUST be ignored, as the meaning of this
      construct at the session level is not well defined.

   For each media section, the following steps MUST be performed; if any
   parameters are out of bounds, or cannot be applied, processing MUST
   stop and an error MUST be returned.

   o  If the description is of type "offer", and the ICE ufrag or
      password changed from the previous remote description, as
      described in Section 9.1.1.1 of [RFC5245], mark that an ICE
      restart is needed.

   o  Configure the ICE components associated with this media section to
      use the supplied ICE remote ufrag and password for their
      connectivity checks.

   o  Pair any supplied ICE candidates with any gathered local
      candidates, as described in Section 5.7 of [RFC5245] and start
      connectivity checks with the appropriate credentials.

   o  If an "a=end-of-candidates" attribute is present, process the end-
      of-candidates indication as described in [I-D.ietf-ice-trickle]
      Section 11.



      *  [TODO: header extensions]

      *  If the m= section is being recycled (see Section 5.2.2),
         dissociate the currently associated RtpTransceiver by setting
         its mid attribute to null.

      *  If the m= section is not associated with any RtpTransceiver
         (possibly because it was dissociated in the previous step),
         either find an RtpTransceiver or create one according to the
         following steps:

         +  If the m= section is sendrecv or recvonly, and there are
            RtpTransceivers of the same type that were added to the
            PeerConnection by addTrack and are not associated with any
            m= section and are not stopped, find the first (according to
            the canonical order described in Section 5.2.1) such
            RtpTransceiver.

         +  If no RtpTransceiver was found in the previous step, create
            one with an inactive RtpSender and active RtpReceiver.

         +  Associate the found or created RtpTransceiver with the m=
            section by setting the value of the RtpTransceiver's mid
            attribute to the MID of the m= section.

      *  For each specified payload type that is also supported by the
         local implementation, establish a mapping between the payload
         type ID and the actual media format.  [TODO - Justin to add
         more to explain mapping.]  If any indicated payload type is
         unknown, it MUST be ignored.  [TODO: should fail on answers]

      *  For each specified "rtx" media format, establish a mapping
         between the RTX payload type and its associated primary payload
         type, as described in [RFC4588].  If any referenced primary
         payload types are not present, this MUST result in an error.

      *  For each specified fmtp parameter that is supported by the
         local implementation, enable them on the associated payload
         types.

      *  For each specified RTCP feedback mechanism that is supported by
         the local implementation, enable them on the associated payload
         types.

      *  For any specified "TIAS" bandwidth value, set this value as a
         constraint on the maximum RTP bitrate to be used when sending
         media, as specified in [RFC3890].  If a "TIAS" value is not


         present, but an "AS" value is specified, generate a "TIAS"
         value using this formula:

         TIAS = AS * 1000 * 0.95 - 50 * 40 * 8

         The 50 is based on 50 packets per second, the 40 is based on an
         estimate of total header size, the 1000 changes the unit from
         kbps to bps (as required by TIAS), and the 0.95 is to allocate
         5% to RTCP.  If more accurate control of bandwidth is needed,
         "TIAS" should be used instead of "AS".

      *  For any "RR" or "RS" bandwidth values, handle as specified in
         [RFC3556], Section 2.

      *  Any specified "CT" bandwidth value MUST be ignored, as the
         meaning of this construct at the media level is not well
         defined.

      *  [TODO: handling of CN, telephone-event, "red"]

      *  If the media section if of type audio:

         +  For any specified "ptime" value, configure the available
            payload types to use the specified packet size.  If the
            specified size is not supported for a payload type, use the
            next closest value instead.

   Finally, if this description is of type "pranswer" or "answer",
   follow the processing defined in the Section 5.9 section below.

5.9.  Applying an Answer

   In addition to the steps mentioned above for processing a local or
   remote description, the following steps are performed when processing
   a description of type "pranswer" or "answer".

   For each media section, the following steps MUST be performed:

   o  If the media section has been rejected (i.e.  port is set to zero
      in the answer), stop any reception or transmission of media for
      this section, and discard any associated ICE components, as
      described in Section 9.2.1.3 of [RFC5245].

   o  If the remote DTLS fingerprint has been changed, tear down the
      existing DTLS connection.




   o  If no valid DTLS connection exists, prepare to start a DTLS
      connection, using the specified roles and fingerprints, on any
      underlying ICE components, once they are active.

   o  If the media section proto value indicates use of RTP:

      *  If the media section has RTCP mux enabled, discard any RTCP
         component, and begin or continue muxing RTCP over the RTP
         component, as specified in [RFC5761], Section 5.1.3.
         Otherwise, transmit RTCP over the RTCP component; if no RTCP
         component exists, because RTCP mux was previously enabled, this
         MUST result in an error.

      *  If the media section has reduced-size RTCP enabled, configure
         the RTCP transmission for this media section to use reduced-
         size RTCP, as specified in [RFC5506].

      *  If the directional attribute in the answer is of type
         "sendrecv" or "sendonly", prepare to start transmitting media
         using the specified primary SSRC and one of the selected
         payload types, once the underlying transport layers have been
         established.  If RID values are specified, include the RID
         header extension in the RTP streams, as indicated in
         [I-D.ietf-mmusic-rid], Section 4).  If simulcast is negotiated,
         send the number of Source RTP Streams as specified in
         [I-D.ietf-mmusic-sdp-simulcast], Section 6.2.2.  If the
         directional attribute is of type "recvonly" or "inactive", stop
         transmitting RTP media, although RTCP should still be sent, as
         described in [RFC3264], Section 5.1.

   o  If the media section proto value indicates use of SCTP:

      *  If no SCTP association yet exists, prepare to initiate a SCTP
         association over the associated ICE component and DTLS
         connection, using the local SCTP port value from the local
         description, and the remote SCTP port value from the remote
         description, as described in [I-D.ietf-mmusic-sctp-sdp],
         Section 10.2.

   If the answer contains valid bundle groups, discard any ICE
   components for the m= sections that will be bundled onto the primary
   ICE components in each bundle, and begin muxing these m= sections
   accordingly, as described in
   [I-D.ietf-mmusic-sdp-bundle-negotiation], Section 8.2.





6.  Configurable SDP Parameters

   It is possible to change elements in the SDP returned from
   createOffer before passing it to setLocalDescription.  When an
   implementation receives modified SDP it MUST either:

   o  Accept the changes and adjust its behavior to match the SDP.

   o  Reject the changes and return an error via the error callback.

   Changes MUST NOT be silently ignored.

   The following elements of the session description MUST NOT be changed
   between the createOffer and the setLocalDescription (or between the
   createAnswer and the setLocalDescription), since they reflect
   transport attributes that are solely under browser control, and the
   browser MUST NOT honor an attempt to change them:

   o  The number, type and port number of m= lines.

   o  The generated MID attributes (a=mid).

   o  The generated ICE credentials (a=ice-ufrag and a=ice-pwd).

   o  The set of ICE candidates and their parameters (a=candidate).

   o  The DTLS fingerprint(s) (a=fingerprint).

   o  The contents of bundle groups, bundle-only parameters, or "a=rtcp-
      mux" parameters.

   The following modifications, if done by the browser to a description
   between createOffer/createAnswer and the setLocalDescription, MUST be
   honored by the browser:

   o  Remove or reorder codecs (m=)

   The following parameters may be controlled by options passed into
   createOffer/createAnswer.  As an open issue, these changes may also
   be be performed by manipulating the SDP returned from createOffer/
   createAnswer, as indicated above, as long as the capabilities of the
   endpoint are not exceeded (e.g. asking for a resolution greater than
   what the endpoint can encode):

   o  [[OPEN ISSUE: This is a placeholder for other modifications, which
      we may continue adding as use cases appear.]]



   Implementations MAY choose to either honor or reject any elements not
   listed in the above two categories, but must do so explicitly as
   described at the beginning of this section.  Note that future
   standards may add new SDP elements to the list of elements which must
   be accepted or rejected, but due to version skew, applications must
   be prepared for implementations to accept changes which must be
   rejected and vice versa.

   The application can also modify the SDP to reduce the capabilities in
   the offer it sends to the far side or the offer that it installs from
   the far side in any way the application sees fit, as long as it is a
   valid SDP offer and specifies a subset of what was in the original
   offer.  This is safe because the answer is not permitted to expand
   capabilities and therefore will just respond to what is actually in
   the offer.

   As always, the application is solely responsible for what it sends to
   the other party, and all incoming SDP will be processed by the
   browser to the extent of its capabilities.  It is an error to assume
   that all SDP is well-formed; however, one should be able to assume
   that any implementation of this specification will be able to
   process, as a remote offer or answer, unmodified SDP coming from any
   other implementation of this specification.

7.  Examples

   Note that this example section shows several SDP fragments.  To
   format in 72 columns, some of the lines in SDP have been split into
   multiple lines, where leading whitespace indicates that a line is a
   continuation of the previous line.  In addition, some blank lines
   have been added to improve readability but are not valid in SDP.

   More examples of SDP for WebRTC call flows can be found in
   [I-D.nandakumar-rtcweb-sdp].

7.1.  Simple Example

   This section shows a very simple example that sets up a minimal audio
   / video call between two browsers and does not use trickle ICE.  The
   example in the following section provides a more realistic example of
   what would happen in a normal browser to browser connection.

   The flow shows Alice's browser initiating the session to Bob's
   browser.  The messages from Alice's JS to Bob's JS are assumed to
   flow over some signaling protocol via a web server.  The JS on both
   Alice's side and Bob's side waits for all candidates before sending
   the offer or answer, so the offers and answers are complete.  Trickle


   ICE is not used.  Both Alice and Bob are using the default policy of
   balanced.


//                  set up local media state
AliceJS->AliceUA:   create new PeerConnection
AliceJS->AliceUA:   addTrack with two tracks: audio and video
AliceJS->AliceUA:   createOffer to get offer
AliceJS->AliceUA:   setLocalDescription with offer
AliceUA->AliceJS:   multiple onicecandidate events with candidates

//                  wait for ICE gathering to complete
AliceUA->AliceJS:   onicecandidate event with null candidate
AliceJS->AliceUA:   get |offer-A1| from pendingLocalDescription

//                  |offer-A1| is sent over signaling protocol to Bob
AliceJS->WebServer: signaling with |offer-A1|
WebServer->BobJS:   signaling with |offer-A1|

//                  |offer-A1| arrives at Bob
BobJS->BobUA:       create a PeerConnection
BobJS->BobUA:       setRemoteDescription with |offer-A1|
BobUA->BobJS:       onaddstream event with remoteStream

//                  Bob accepts call
BobJS->BobUA:       addTrack with local tracks
BobJS->BobUA:       createAnswer
BobJS->BobUA:       setLocalDescription with answer
BobUA->BobJS:       multiple onicecandidate events with candidates

//                  wait for ICE gathering to complete
BobUA->BobJS:       onicecandidate event with null candidate
BobJS->BobUA:       get |answer-A1| from currentLocalDescription

//                  |answer-A1| is sent over signaling protocol to Alice
BobJS->WebServer:   signaling with |answer-A1|
WebServer->AliceJS: signaling with |answer-A1|

//                  |answer-A1| arrives at Alice
AliceJS->AliceUA:   setRemoteDescription with |answer-A1|
AliceUA->AliceJS:   onaddstream event with remoteStream

//                  media flows
BobUA->AliceUA:     media sent from Bob to Alice
AliceUA->BobUA:     media sent from Alice to Bob




   v=0
   o=- 4962303333179871722 1 IN IP4 0.0.0.0
   s=-
   t=0 0
   a=group:BUNDLE a1 v1
   a=ice-options:trickle
   m=audio 56500 UDP/TLS/RTP/SAVPF 96 0 8 97 98
   c=IN IP4 192.0.2.1
   a=mid:a1
   a=rtcp:56501 IN IP4 192.0.2.1
   a=msid:47017fee-b6c1-4162-929c-a25110252400
          f83006c5-a0ff-4e0a-9ed9-d3e6747be7d9
   a=sendrecv
   a=rtpmap:96 opus/48000/2
   a=rtpmap:0 PCMU/8000
   a=rtpmap:8 PCMA/8000
   a=rtpmap:97 telephone-event/8000
   a=rtpmap:98 telephone-event/48000
   a=maxptime:120
   a=ice-ufrag:ETEn1v9DoTMB9J4r
   a=ice-pwd:OtSK0WpNtpUjkY4+86js7ZQl
   a=fingerprint:sha-256
                 19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04
                :BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
   a=setup:actpass
   a=rtcp-mux
   a=rtcp-rsize
   a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level
   a=extmap:2 urn:ietf:params:rtp-hdrext:sdes:mid
   a=ssrc:1732846380 cname:EocUG1f0fcg/yvY7
   a=candidate:3348148302 1 udp 2113937151 192.0.2.1 56500
               typ host
   a=candidate:3348148302 2 udp 2113937151 192.0.2.1 56501
               typ host
   a=end-of-candidates

   m=video 56502 UDP/TLS/RTP/SAVPF 100 101
   c=IN IP4 192.0.2.1
   a=rtcp:56503 IN IP4 192.0.2.1
   a=mid:v1
   a=msid:61317484-2ed4-49d7-9eb7-1414322a7aae
          f30bdb4a-5db8-49b5-bcdc-e0c9a23172e0
   a=sendrecv
   a=rtpmap:100 VP8/90000
   a=rtpmap:101 rtx/90000
   a=fmtp:101 apt=100
   a=ice-ufrag:BGKkWnG5GmiUpdIV


   a=fingerprint:sha-256
                 19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04
                :BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
   a=setup:actpass
   a=rtcp-mux
   a=rtcp-rsize
   a=extmap:3 urn:ietf:params:rtp-hdrext:sdes:mid
   a=rtcp-fb:100 ccm fir
   a=rtcp-fb:100 nack
   a=rtcp-fb:100 nack pli
   a=ssrc:1366781083 cname:EocUG1f0fcg/yvY7
   a=ssrc:1366781084 cname:EocUG1f0fcg/yvY7
   a=ssrc-group:FID 1366781083 1366781084
   a=candidate:3348148302 1 udp 2113937151 192.0.2.1 56502
               typ host
   a=candidate:3348148302 2 udp 2113937151 192.0.2.1 56503
               typ host
   a=end-of-candidates


   The SDP for |answer-A1| looks like:


   v=0
   o=- 6729291447651054566 1 IN IP4 0.0.0.0
   s=-
   t=0 0
   a=group:BUNDLE a1 v1
   m=audio 20000 UDP/TLS/RTP/SAVPF 96 0 8 97 98
   c=IN IP4 192.0.2.2
   a=mid:a1
   a=rtcp:20000 IN IP4 192.0.2.2
   a=msid:PI39StLS8W7ZbQl1sJsWUXkr3Zf12fJUvzQ1
          PI39StLS8W7ZbQl1sJsWUXkr3Zf12fJUvzQ1a0
   a=sendrecv
   a=rtpmap:96 opus/48000/2
   a=rtpmap:0 PCMU/8000
   a=rtpmap:8 PCMA/8000
   a=rtpmap:97 telephone-event/8000
   a=rtpmap:98 telephone-event/48000
   a=maxptime:120
   a=ice-ufrag:6sFvz2gdLkEwjZEr
   a=ice-pwd:cOTZKZNVlO9RSGsEGM63JXT2
   a=fingerprint:sha-256 6B:8B:F0:65:5F:78:E2:51:3B:AC:6F:F3:3F:46:1B:35
               :DC:B8:5F:64:1A:24:C2:43:F0:A1:58:D0:A1:2C:19:08
   a=setup:active
   a=rtcp-mux


   a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level
   a=ssrc:3429951804 cname:Q/NWs1ao1HmN4Xa5
   a=candidate:2299743422 1 udp 2113937151 192.0.2.2 20000
               typ host
   a=end-of-candidates

   m=video 20000 UDP/TLS/RTP/SAVPF 100 101
   c=IN IP4 192.0.2.2
   a=rtcp 20001 IN IP4 192.0.2.2
   a=mid:v1
   a=msid:PI39StLS8W7ZbQl1sJsWUXkr3Zf12fJUvzQ1
          PI39StLS8W7ZbQl1sJsWUXkr3Zf12fJUvzQ1v0
   a=sendrecv
   a=rtpmap:100 VP8/90000
   a=rtpmap:101 rtx/90000
   a=fmtp:101 apt=100
   a=fingerprint:sha-256 6B:8B:F0:65:5F:78:E2:51:3B:AC:6F:F3:3F:46:1B:35
                        :DC:B8:5F:64:1A:24:C2:43:F0:A1:58:D0:A1:2C:19:08
   a=setup:active
   a=rtcp-mux
   a=rtcp-rsize
   a=rtcp-fb:100 ccm fir
   a=rtcp-fb:100 nack
   a=rtcp-fb:100 nack pli
   a=ssrc:3229706345 cname:Q/NWs1ao1HmN4Xa5
   a=ssrc:3229706346 cname:Q/NWs1ao1HmN4Xa5
   a=ssrc-group:FID 3229706345 3229706346


7.2.  Normal Examples

   This section shows a typical example of a session between two
   browsers setting up an audio channel and a data channel.  Trickle ICE
   is used in full trickle mode with a bundle policy of max-bundle, an
   RTCP mux policy of require, and a single TURN server.  Later, two
   video flows, one for the presenter and one for screen sharing, are
   added to the session.  This example shows Alice's browser initiating
   the session to Bob's browser.  The messages from Alice's JS to Bob's
   JS are assumed to flow over some signaling protocol via a web server.


  //                  set up local media state
  AliceJS->AliceUA:   create new PeerConnection
  AliceJS->AliceUA:   addTrack with an audio track
  AliceJS->AliceUA:   createDataChannel to get data channel
  AliceJS->AliceUA:   createOffer to get |offer-B1|
  AliceJS->AliceUA:   setLocalDescription with |offer-B1|


  //                  |offer-B1| is sent over signaling protocol to Bob
  AliceJS->WebServer: signaling with |offer-B1|
  WebServer->BobJS:   signaling with |offer-B1|

  //                  |offer-B1| arrives at Bob
  BobJS->BobUA:       create a PeerConnection
  BobJS->BobUA:       setRemoteDescription with |offer-B1|
  BobUA->BobJS:       onaddstream with audio track from Alice

  //                  candidates are sent to Bob
  AliceUA->AliceJS:   onicecandidate event with |candidate-B1| (host)
  AliceJS->WebServer: signaling with |candidate-B1|
  AliceUA->AliceJS:   onicecandidate event with |candidate-B2| (srflx)
  AliceJS->WebServer: signaling with |candidate-B2|

  WebServer->BobJS:   signaling with |candidate-B1|
  BobJS->BobUA:       addIceCandidate with |candidate-B1|
  WebServer->BobJS:   signaling with |candidate-B2|
  BobJS->BobUA:       addIceCandidate with |candidate-B2|

  //                  Bob accepts call
  BobJS->BobUA:       addTrack with local audio
  BobJS->BobUA:       createDataChannel to get data channel
  BobJS->BobUA:       createAnswer to get |answer-B1|
  BobJS->BobUA:       setLocalDescription with |answer-B1|

  //                  |answer-B1| is sent to Alice
  BobJS->WebServer:   signaling with |answer-B1|
  WebServer->AliceJS: signaling with |answer-B1|
  AliceJS->AliceUA:   setRemoteDescription with |answer-B1|
  AliceUA->AliceJS:   onaddstream event with audio track from Bob

  //                  candidates are sent to Alice
  BobUA->BobJS:       onicecandidate event with |candidate-B3| (host)
  BobJS->WebServer:   signaling with |candidate-B3|
  BobUA->BobJS:       onicecandidate event with |candidate-B4| (srflx)
  BobJS->WebServer:   signaling with |candidate-B4|

  WebServer->AliceJS: signaling with |candidate-B3|
  AliceJS->AliceUA:   addIceCandidate with |candidate-B3|
  WebServer->AliceJS: signaling with |candidate-B4|
  AliceJS->AliceUA:   addIceCandidate with |candidate-B4|

  //                  data channel opens
  BobUA->BobJS:       ondatachannel event
  AliceUA->AliceJS:   ondatachannel event
  BobUA->BobJS:       onopen


  //                  media is flowing between browsers
  BobUA->AliceUA:     audio+data sent from Bob to Alice
  AliceUA->BobUA:     audio+data sent from Alice to Bob

  //                  some time later Bob adds two video streams
  //                  note, no candidates exchanged, because of bundle
  BobJS->BobUA:       addTrack with first video stream
  BobJS->BobUA:       addTrack with second video stream
  BobJS->BobUA:       createOffer to get |offer-B2|
  BobJS->BobUA:       setLocalDescription with |offer-B2|

  //                  |offer-B2| is sent to Alice
  BobJS->WebServer:   signaling with |offer-B2|
  WebServer->AliceJS: signaling with |offer-B2|
  AliceJS->AliceUA:   setRemoteDescription with |offer-B2|
  AliceUA->AliceJS:   onaddstream event with first video stream
  AliceUA->AliceJS:   onaddstream event with second video stream
  AliceJS->AliceUA:   createAnswer to get |answer-B2|
  AliceJS->AliceUA:   setLocalDescription with |answer-B2|

  //                  |answer-B2| is sent over signaling protocol to Bob
  AliceJS->WebServer: signaling with |answer-B2|
  WebServer->BobJS:   signaling with |answer-B2|
  BobJS->BobUA:       setRemoteDescription with |answer-B2|

  //                  media is flowing between browsers
  BobUA->AliceUA:     audio+video+data sent from Bob to Alice
  AliceUA->BobUA:     audio+video+data sent from Alice to Bob


   The SDP for |offer-B1| looks like:


















   v=0
   o=- 4962303333179871723 1 IN IP4 0.0.0.0
   s=-
   t=0 0
   a=group:BUNDLE a1 d1
   a=ice-options:trickle
   m=audio 9 UDP/TLS/RTP/SAVPF 96 0 8 97 98
   c=IN IP4 0.0.0.0
   a=rtcp:9 IN IP4 0.0.0.0
   a=mid:a1
   a=msid:57017fee-b6c1-4162-929c-a25110252400
          e83006c5-a0ff-4e0a-9ed9-d3e6747be7d9
   a=sendrecv
   a=rtpmap:96 opus/48000/2
   a=rtpmap:0 PCMU/8000
   a=rtpmap:8 PCMA/8000
   a=rtpmap:97 telephone-event/8000
   a=rtpmap:98 telephone-event/48000
   a=maxptime:120
   a=ice-ufrag:ATEn1v9DoTMB9J4r
   a=ice-pwd:AtSK0WpNtpUjkY4+86js7ZQl
   a=fingerprint:sha-256
                 19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04
                :BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
   a=setup:actpass
   a=rtcp-mux
   a=rtcp-rsize
   a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level
   a=extmap:2 urn:ietf:params:rtp-hdrext:sdes:mid
   a=ssrc:1732846380 cname:FocUG1f0fcg/yvY7

   m=application 0 UDP/DTLS/SCTP webrtc-datachannel
   c=IN IP4 0.0.0.0
   a=bundle-only
   a=mid:d1
   a=fmtp:webrtc-datachannel max-message-size=65536
   a=sctp-port 5000
   a=fingerprint:sha-256 19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04
                        :BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
   a=setup:actpass


   The SDP for |candidate-B1| looks like:


   candidate:109270923 1 udp 2122194687 192.168.1.2 51556 typ host



   The SDP for |candidate-B2| looks like:


   candidate:4036177503 1 udp 1685987071 11.22.33.44 52546 typ srflx
             raddr 192.168.1.2 rport 51556


   The SDP for |answer-B1| looks like:









































   v=0
   o=- 7729291447651054566 1 IN IP4 0.0.0.0
   s=-
   t=0 0
   a=group:BUNDLE a1 d1
   a=ice-options:trickle
   m=audio 9 UDP/TLS/RTP/SAVPF 96 0 8 97 98
   c=IN IP4 0.0.0.0
   a=rtcp:9 IN IP4 0.0.0.0
   a=mid:a1
   a=msid:QI39StLS8W7ZbQl1sJsWUXkr3Zf12fJUvzQ1
          QI39StLS8W7ZbQl1sJsWUXkr3Zf12fJUvzQ1a0
   a=sendrecv
   a=rtpmap:96 opus/48000/2
   a=rtpmap:0 PCMU/8000
   a=rtpmap:8 PCMA/8000
   a=rtpmap:97 telephone-event/8000
   a=rtpmap:98 telephone-event/48000
   a=maxptime:120
   a=ice-ufrag:7sFvz2gdLkEwjZEr
   a=ice-pwd:dOTZKZNVlO9RSGsEGM63JXT2
   a=fingerprint:sha-256 6B:8B:F0:65:5F:78:E2:51:3B:AC:6F:F3:3F:46:1B:35
                        :DC:B8:5F:64:1A:24:C2:43:F0:A1:58:D0:A1:2C:19:08
   a=setup:active
   a=rtcp-mux
   a=rtcp-rsize
   a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level
   a=extmap:2 urn:ietf:params:rtp-hdrext:sdes:mid
   a=ssrc:4429951804 cname:Q/NWs1ao1HmN4Xa5

   m=application 9 UDP/DTLS/SCTP webrtc-datachannel
   c=IN IP4 0.0.0.0
   a=mid:d1
   a=fmtp:webrtc-datachannel max-message-size=65536
   a=sctp-port 5000
   a=fingerprint:sha-256 6B:8B:F0:65:5F:78:E2:51:3B:AC:6F:F3:3F:46:1B:35
                        :DC:B8:5F:64:1A:24:C2:43:F0:A1:58:D0:A1:2C:19:08
   a=setup:active


   The SDP for |candidate-B3| looks like:


   candidate:109270924 1 udp 2122194687 192.168.2.3 61665 typ host


   The SDP for |candidate-B4| looks like:


   candidate:4036177504 1 udp 1685987071 55.66.77.88 64532 typ srflx
             raddr 192.168.2.3 rport 61665


   The SDP for |offer-B2| looks like: (note the increment of the version
   number in the o= line, and the c= and a=rtcp lines, which indicate
   the local candidate that was selected)


   v=0
   o=- 7729291447651054566 2 IN IP4 0.0.0.0
   s=-
   t=0 0
   a=group:BUNDLE a1 d1 v1 v2
   a=ice-options:trickle
   m=audio 64532 UDP/TLS/RTP/SAVPF 96 0 8 97 98
   c=IN IP4 55.66.77.88
   a=rtcp:64532 IN IP4 55.66.77.88
   a=mid:a1
   a=msid:QI39StLS8W7ZbQl1sJsWUXkr3Zf12fJUvzQ1
          QI39StLS8W7ZbQl1sJsWUXkr3Zf12fJUvzQ1a0
   a=sendrecv
   a=rtpmap:96 opus/48000/2
   a=rtpmap:0 PCMU/8000
   a=rtpmap:8 PCMA/8000
   a=rtpmap:97 telephone-event/8000
   a=rtpmap:98 telephone-event/48000
   a=maxptime:120
   a=ice-ufrag:7sFvz2gdLkEwjZEr
   a=ice-pwd:dOTZKZNVlO9RSGsEGM63JXT2
   a=fingerprint:sha-256 6B:8B:F0:65:5F:78:E2:51:3B:AC:6F:F3:3F:46:1B:35
                        :DC:B8:5F:64:1A:24:C2:43:F0:A1:58:D0:A1:2C:19:08
   a=setup:actpass
   a=rtcp-mux
   a=rtcp-rsize
   a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level
   a=extmap:2 urn:ietf:params:rtp-hdrext:sdes:mid
   a=ssrc:4429951804 cname:Q/NWs1ao1HmN4Xa5
   a=candidate:109270924 1 udp 2122194687 192.168.2.3 61665 typ host
   a=candidate:4036177504 1 udp 1685987071 55.66.77.88 64532 typ srflx
               raddr 192.168.2.3 rport 61665
   a=candidate:3671762467 1 udp 41819903 66.77.88.99 50416 typ relay
               raddr 55.66.77.88 rport 64532
   a=end-of-candidates

   m=application 64532 UDP/DTLS/SCTP webrtc-datachannel
   c=IN IP4 55.66.77.88


   a=fmtp:webrtc-datachannel max-message-size=65536
   a=sctp-port 5000
   a=ice-ufrag:7sFvz2gdLkEwjZEr
   a=ice-pwd:dOTZKZNVlO9RSGsEGM63JXT2
   a=fingerprint:sha-256 6B:8B:F0:65:5F:78:E2:51:3B:AC:6F:F3:3F:46:1B:35
                        :DC:B8:5F:64:1A:24:C2:43:F0:A1:58:D0:A1:2C:19:08
   a=setup:actpass
   a=candidate:109270924 1 udp 2122194687 192.168.2.3 61665 typ host
   a=candidate:4036177504 1 udp 1685987071 55.66.77.88 64532 typ srflx
               raddr 192.168.2.3 rport 61665
   a=candidate:3671762467 1 udp 41819903 66.77.88.99 50416 typ relay
               raddr 55.66.77.88 rport 64532
   a=end-of-candidates

   m=video 0 UDP/TLS/RTP/SAVPF 100 101
   c=IN IP4 55.66.77.88
   a=bundle-only
   a=rtcp:64532 IN IP4 55.66.77.88
   a=mid:v1
   a=msid:61317484-2ed4-49d7-9eb7-1414322a7aae
          f30bdb4a-5db8-49b5-bcdc-e0c9a23172e0
   a=sendrecv
   a=rtpmap:100 VP8/90000
   a=rtpmap:101 rtx/90000
   a=fmtp:101 apt=100
   a=fingerprint:sha-256
                 19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04
                :BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
   a=setup:actpass
   a=rtcp-mux
   a=rtcp-rsize
   a=extmap:2 urn:ietf:params:rtp-hdrext:sdes:mid
   a=rtcp-fb:100 ccm fir
   a=rtcp-fb:100 nack
   a=rtcp-fb:100 nack pli
   a=ssrc:1366781083 cname:Q/NWs1ao1HmN4Xa5
   a=ssrc:1366781084 cname:Q/NWs1ao1HmN4Xa5
   a=ssrc-group:FID 1366781083 1366781084

   m=video 0 UDP/TLS/RTP/SAVPF 100 101
   c=IN IP4 55.66.77.88
   a=bundle-only
   a=rtcp:64532 IN IP4 55.66.77.88
   a=mid:v1
   a=msid:71317484-2ed4-49d7-9eb7-1414322a7aae
          f30bdb4a-5db8-49b5-bcdc-e0c9a23172e0
   a=sendrecv


   a=rtpmap:101 rtx/90000
   a=fmtp:101 apt=100
   a=fingerprint:sha-256
                 19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04
                :BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
   a=setup:actpass
   a=rtcp-mux
   a=rtcp-rsize
   a=extmap:2 urn:ietf:params:rtp-hdrext:sdes:mid
   a=rtcp-fb:100 ccm fir
   a=rtcp-fb:100 nack
   a=rtcp-fb:100 nack pli
   a=ssrc:2366781083 cname:Q/NWs1ao1HmN4Xa5
   a=ssrc:2366781084 cname:Q/NWs1ao1HmN4Xa5
   a=ssrc-group:FID 2366781083 2366781084


   The SDP for |answer-B2| looks like: (note the use of setup:passive to
   maintain the existing DTLS roles, and the use of a=recvonly to
   indicate that the video streams are one-way)


   v=0
   o=- 4962303333179871723 2 IN IP4 0.0.0.0
   s=-
   t=0 0
   a=group:BUNDLE a1 d1 v1 v2
   a=ice-options:trickle
   m=audio 52546 UDP/TLS/RTP/SAVPF 96 0 8 97 98
   c=IN IP4 11.22.33.44
   a=rtcp:52546 IN IP4 11.22.33.44
   a=mid:a1
   a=msid:57017fee-b6c1-4162-929c-a25110252400
          e83006c5-a0ff-4e0a-9ed9-d3e6747be7d9
   a=sendrecv
   a=rtpmap:96 opus/48000/2
   a=rtpmap:0 PCMU/8000
   a=rtpmap:8 PCMA/8000
   a=rtpmap:97 telephone-event/8000
   a=rtpmap:98 telephone-event/48000
   a=maxptime:120
   a=ice-ufrag:ATEn1v9DoTMB9J4r
   a=ice-pwd:AtSK0WpNtpUjkY4+86js7ZQl
   a=fingerprint:sha-256
                 19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04
                :BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
   a=setup:passive


   a=rtcp-rsize
   a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level
   a=extmap:2 urn:ietf:params:rtp-hdrext:sdes:mid
   a=ssrc:1732846380 cname:FocUG1f0fcg/yvY7
   a=candidate:109270923 1 udp 2122194687 192.168.1.2 51556 typ host
   a=candidate:4036177503 1 udp 1685987071 11.22.33.44 52546 typ srflx
               raddr 192.168.1.2 rport 51556
   a=candidate:3671762466 1 udp 41819903 22.33.44.55 61405 typ relay
               raddr 11.22.33.44 rport 52546
   a=end-of-candidates

   m=application 52546 UDP/DTLS/SCTP webrtc-datachannel
   c=IN IP4 11.22.33.44
   a=mid:d1
   a=fmtp:webrtc-datachannel max-message-size=65536
   a=sctp-port 5000
   a=fingerprint:sha-256 19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04
                        :BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
   a=setup:passive

   m=video 52546 UDP/TLS/RTP/SAVPF 100 101
   c=IN IP4 11.22.33.44
   a=rtcp:52546 IN IP4 11.22.33.44
   a=mid:v1
   a=recvonly
   a=rtpmap:100 VP8/90000
   a=rtpmap:101 rtx/90000
   a=fmtp:101 apt=100
   a=fingerprint:sha-256
                 19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04
                :BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
   a=setup:passive
   a=rtcp-mux
   a=rtcp-rsize
   a=extmap:2 urn:ietf:params:rtp-hdrext:sdes:mid
   a=rtcp-fb:100 ccm fir
   a=rtcp-fb:100 nack
   a=rtcp-fb:100 nack pli

   m=video 52546 UDP/TLS/RTP/SAVPF 100 101
   c=IN IP4 11.22.33.44
   a=rtcp:52546 IN IP4 11.22.33.44
   a=mid:v2
   a=recvonly
   a=rtpmap:100 VP8/90000
   a=rtpmap:101 rtx/90000
   a=fmtp:101 apt=100


                 19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04
                :BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
   a=setup:passive
   a=rtcp-mux
   a=rtcp-rsize
   a=extmap:2 urn:ietf:params:rtp-hdrext:sdes:mid
   a=rtcp-fb:100 ccm fir
   a=rtcp-fb:100 nack
   a=rtcp-fb:100 nack pli


8.  Security Considerations

   The IETF has published separate documents
   [I-D.ietf-rtcweb-security-arch] [I-D.ietf-rtcweb-security] describing
   the security architecture for WebRTC as a whole.  The remainder of
   this section describes security considerations for this document.

   While formally the JSEP interface is an API, it is better to think of
   it is an Internet protocol, with the JS being untrustworthy from the
   perspective of the browser.  Thus, the threat model of [RFC3552]
   applies.  In particular, JS can call the API in any order and with
   any inputs, including malicious ones.  This is particularly relevant
   when we consider the SDP which is passed to setLocalDescription().
   While correct API usage requires that the application pass in SDP
   which was derived from createOffer() or createAnswer() (perhaps
   suitably modified as described in Section 6, there is no guarantee
   that applications do so.  The browser MUST be prepared for the JS to
   pass in bogus data instead.

   Conversely, the application programmer MUST recognize that the JS
   does not have complete control of browser behavior.  One case that
   bears particular mention is that editing ICE candidates out of the
   SDP or suppressing trickled candidates does not have the expected
   behavior: implementations will still perform checks from those
   candidates even if they are not sent to the other side.  Thus, for
   instance, it is not possible to prevent the remote peer from learning
   your public IP address by removing server reflexive candidates.
   Applications which wish to conceal their public IP address should
   instead configure the ICE agent to use only relay candidates.

<- RFC


###todo:
✓ [overview](https://tools.ietf.org/html/draft-ietf-rtcweb-overview-15)
+ [jsep](https://tools.ietf.org/html/draft-ietf-rtcweb-jsep) <- I'm here
* актуализировать ссылки
+ [use cases](https://tools.ietf.org/html/rfc7478)
- [SDP + ICE](https://tools.ietf.org/html/draft-ietf-rtcweb-sdp-02)
- [RTP](https://tools.ietf.org/html/draft-ietf-rtcweb-rtp-usage)
- [SRTP](https://tools.ietf.org/html/rfc7201)
+ [security considerations](https://tools.ietf.org/html/draft-ietf-rtcweb-security)
- [security architecture](https://tools.ietf.org/html/draft-ietf-rtcweb-security-arch)
- [DSCP, Qos](https://tools.ietf.org/html/draft-ietf-tsvwg-rtcweb-qos)
- [data channels](https://tools.ietf.org/html/draft-ietf-rtcweb-data-channel)
- [data channels establishment](https://tools.ietf.org/html/draft-ietf-rtcweb-data-protocol)
+ [audio codecs](https://tools.ietf.org/html/rfc7874)
- [video codecs](https://tools.ietf.org/html/rfc7742)
- media server

###thesaurus

session definitions - сессионные датаграммы
